# 由B+树引发的随想

[TOC]



## B树漫谈

说起B+树、B-树，我想我自认为已经很熟悉了，在《MySQL优化学习手札(一)》、《B-树如何让你的查询更快》中已经讨论过了，事实上在计算机领域有些名词倒是没有严格的概念，我们常常听到B 树、B-树、B+树，B树和B-树事实上应该是同义语，B- 树的减号是一个连字符，也就是self-balancing中的减号。我们回忆一下《B-树如何让你的查询更快中》这篇文章的内容，我们首先是从查找数据谈起，我们在存储数据的时候，要为取数据考虑，我们首先从二叉搜索树谈起，在二叉搜索树中，右边节点的数字总是比双亲节点大，左节点的数据总是比双亲节点要小，如下图所示:

![](https://a.a2k6.com/gerald/i/2024/03/13/xxv4.webp)



现在这颗二叉搜索树包含七个节点，但是我们最多需要访问三个节点才能找到我们想要找到的数字，比如我们搜索14，首先与根结点比较一次，比根结点大，然后来到它的子树，与15做比较，发现比15小，那应该15的左子树去找，于是和14比较，发现相等，于是找到了我们想要的数据。单纯从查询性能来看，二叉搜索树是一个不错的选择， 花费的时间复杂度是O(logn)，和B树一样，但是我们需要为我们的数据寻找一个好的存储介质，在计算机上存储介质我们举目望去也就只有内存和磁盘了，别打CPU缓存的主意那很小，根本存储不了多少数据。全部存储在内存中，但是一般的内存也不够大，我们要存储的数据最大可能在几百GB左右，内存还有一个缺点就是断电数据就消失了，为此我们不得不考虑持久化工作，考虑存储大小，我们不能将内存当作存储数据的地方，我们可以使用内存来加速数据访问。

于是最后就只剩下磁盘，而磁盘读取又分为随机读取和顺序读取，所谓随机读取就是读指定位置的数据，磁盘可以抽象为一排排存储数据的容器，每个容器都有对应的编号:

![](https://a.a2k6.com/gerald/i/2024/03/14/3jkyi.webp)

读1、4、6，注意这三个容器没有连接在一起，这就需要磁头(原谅我们在2024年依然还是选择使用机械硬盘，在早期机械硬盘很便宜，这让我们在编写软件的时候不得不考虑这一点)， 跳转到1，然后跳转到4，再跳转到5。这也被称为随机读取。现在让我们读3、4、5这三个容器的值，这就只需要旋转磁盘，让磁头读取连续的值，在读取兆字节数据的时候，这两种访问的差异是巨大的，使用”顺序读取“可以大大的降低获取数据所需的时间。让我们回到上面的例子，上面那颗二叉搜索树在磁盘上的存储如下图所示:

这就是在内存级别的样子:

![](https://a.a2k6.com/gerald/i/2024/03/14/iuoe.webp)

![](https://a.a2k6.com/gerald/i/2024/03/14/iskr.webp)

执行查询的时候，内存地址1,3,6会被访问，访问三个节点不是问题，然而，如果我们存储了更多数据，这棵树就可能变得更高。存储超过100万个值需要一颗高度至少为20的树。这意味着必须从内存不同位置读取20个值，这会导致完全的随机访问。

到现在我们已经直到了，树太高会导致随机访问次数变多，拖慢查询速度，为了提升查询速度，我们需要让树变得矮一点，解决这一问题也很简单: 让树变宽而不是高度增长。可以通过将多个值打包到一个节点来实现。我们可以将上面的二叉树改装成下面的类型:

![](https://a.a2k6.com/gerald/i/2024/03/14/qc6dv.webp)

请注意每次我们访问一个节点，我们都需要加载这个节点所有的值，在这个例子中，我们需要加载4个值(如果树是满的，就需要6个值)才能找到我们需要的值。下面是这棵树在内存中的展示

![](https://a.a2k6.com/gerald/i/2024/03/14/3rqe3.webp)

与上一个示例相比(树的高度不断增加)，搜索应当更快，我们仅需要随机访问两次(跳转到0和9单元)，然后顺序读取剩余的值。

它与现实又是如何联系的呢？ Postgres的页面大小只有8kb，假设20%是元数据，那么还剩下6kb。页面的一半需要存储指向子节点的指针，所以给我们存储值剩余的空间就只剩下3kb，BIGINT的大小是8 bytes，因此我们能存储375个值再单个页面里面。假设数据库有一些超级大的表有10亿条记录，那么我们在postgres树种需要多层才能存储? 根据上面的计算，单个节点可以存储375个值，它可以只有四层的树来存储10亿个值。对于如此大量的数据，二叉搜索树将需要30层来存储。

这里我们解决了高度的问题，但是还有一个问题值得我们警惕，也就是树的退化，树的形状取决于添加进入树的顺序，这在二叉树中很容易看到:

![](https://a.a2k6.com/gerald/i/2024/03/14/ke4w.webp)

我们可以看到在一些极端情况下树会进行退化，退化成链表，这会拖慢我们的查询速度，于是我们需要自平衡，这也就是B树中自平衡算法。到现在为止我们已经明确了选择B+树作为关系型数据库存储数据结构的理由，一是我们希望在存储更多数据的同时让树没有那么高，于是我们需要将多个值打包进入一个节点，也就是通过让树变宽的方式让树变矮，同时为了避免随机访问，我们在读取的时候要尽量做顺序访问，为了避免在极端情况下树退化成链表，我们需要引入自平衡算法来让树做自平衡。

## MySQL中的B+树

我们回到MySQL中的B+树，关于MySQL的B+树，我们在《MySQL优化学习手札(一)》已经进行了充分的讨论，我们回忆一下两年前这篇文章的内容, 为了降低I/O次数，MySQL选择以页为单位管理数据，也就是说MySQL不会逐行将数据加载进入内存，而是选择以页为单位进行读取，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为16KB，通过show global status like 'innodb_page_size'; 可查看一页的大小。

在MySQL中行与行之间构成一个单链表，每个行记录里面存储了下一行的地址，所有的记录按照主键，从小到大组成了一个单链表，上面我们也提到Innodb以页面为单位来存储数据，我们姑且可以认为我们平时查找的行都是放在页面里面，如下面的图所示:

![](https://a.a2k6.com/gerald/i/2024/05/05/145ftd.jpg)

如果页面之间没有规律，那么即使单个页面里面是有序的我们也得遍历整个表，这无疑是我们不想看到的，于是我们希望页面与页面之间也保持顺序，下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值，同时数据页之间是一个双向链表，那为什么要维持双向链表呢? 原因在于有些数据页会被移除，我们添加的数据页可能走从最后到最前最近，也可能走最前到最后最近，所以到现在为止我们的数据存储结构如下图所示:

![](https://a.a2k6.com/gerald/i/2024/05/05/82ffpe.jpg)

你想到了什么呢，你是否想到了树呢，我们可以将这些页面的最大记录提取出来，做一个新的页面，我们姑且就称之为目录项吧，目录项存储页号和主键:







MySQL中的B+树的特点是:

1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：

   - 页内的记录是按照主键的大小顺序排成一个单向链表。
   - 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。
   - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。

2. `B+`树的叶子节点存储的是完整的用户记录。

   所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

于是我们可以得出这样的结论吗？ B+树必须是:

让我们看看MongDB的B+树，

## MongDB的B+树







## 非B+树不可吗？

写到这里，我想起很久之前我看的一篇技术文章说为什么MySQL为什么选择B+树作为存储数据的数据结构，当时列举了一堆数据结构，说使用哈希作为存储的数据



让我们来看MongDB



中的B+树，

于是想起了哈希索引



但是引发我这篇文章思考的一个点在于MongDB论坛上的一个讨论，MongDB中的索引是B+树 还是 B 树，

这让我的思考是不要思维定势，要实事求是，

于是让我想到了哈希索引，

## 对比一下MongDB 和 MySQL







## 参考资料

[1]  What are the differences between B trees and B+ trees?

[2] 