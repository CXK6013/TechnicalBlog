# 当数组遇上队列: Java线程安全实现详解(一)

> 当你养成一种分析问题、琢磨文章的习惯之后，日积月累；你便会感到复杂的东西也是由少数几个大的部分组成的。这些部分出现的原因和它们之间的相互关系也是可以理解的。与此同时，由于读的东西多了，运算的技巧也高了，你会发现，一些复杂的推演过程大部分是由某些必然的步骤所组成，就比较容易抓住新的关键性的部分 ---  越民义

[TOC]

> 这是一个系列的文章，我们会逐步完善。用到什么讲什么。

## 前言

最近碰上个有趣的题目，用数组实现一个队列，要求线程安全，高性能。这个问题刚好能糅合一些对基础知识的运用，于是打算做一下，同时展开自己的思考过程。要求是递进式的，首先是用数组实现一个队列，队列的特点是先进先出，先进先出意味着我们要提供一个方法入队和出队方法:

- pushBack:  将元素放到队尾，如果队列满了，返回添加失败。
- popFront:   从队头开始出队 ，如果队列为空返回失败。

也可以是从队头入队，然后从队尾出队:

- pushFront: 队头入队   如果队列满了，返回添加失败
- popBack:  队尾出队

![](https://a.a2k6.com/gerald/i/2024/06/28/45qf.png)

有时候我们也希望知道这个队列实际存储了几个元素:

- size方法: 返回了队列实际存储了多少个元素

## 首先用数组实现队列

有了设计目标就可以着手编写代码了，在Java里面首先我们需要一个类，类里面存放数据和行为, 为了让我们的队列更通用一些，我们将为我们的队列引入泛型支持，但是在Java中无法实现泛型数组的语法，也就是下面这样:

```java
T[] array = new T[5];
```

在C#中我们就可以这么声明:

```java
using System;
class Program
{
    public static void Main(string[] args)
    {
          // 声明并初始化一个整型数组
        int[] intArray = new int[5];
        intArray[0] = 1;
        Console.WriteLine(intArray[0]);

        // 声明并初始化一个字符串数组
        string[] stringArray = new string[5];
        stringArray[0] = "Hello";
        Console.WriteLine(stringArray[0]);

        // 使用泛型方法创建和操作泛型数组
        CreateAndOperateArray<int>(10, 5);
        CreateAndOperateArray<string>("World", 5);
    }
    static void CreateAndOperateArray<T>(T initialValue, int size)
    {
        T[] array = new T[size];
        array[0] = initialValue;
        Console.WriteLine(array[0]);
    }
}
```

回顾ArrayList的实现你会发现，ArrayList实现泛型化，底层仍然是一个Object数组，然后在get的时候，做了强制类型转换

```java
public E get(int index) {
    rangeCheck(index);
    return elementData(index);
}
```

```java
@SuppressWarnings("unchecked")
E elementData(int index) {
    return (E) elementData[index];
}
```

所以我们也是用这样的思路来解决类型转换问题。解决完泛型问题，我们来设计pushBack方法，这个方法的设计目标是将请求入队的元素放在队尾，如果我们基于引用实现，在类里面我们可以放一个尾节点(指针)指向最后一个节点。用数组实现的时候我们存储的就是尾节点的下标了，在一开始队列初始化的时候尾结点和头节点可以都指向0下标，于是我们就需要有一个方法计算出来我们的元素应该放在哪个位置，我们自然就想到了取余，pushBack方法将元素放在队尾，设定我们有hello5、hello4、hello3、hello2、hello1 这五个元素依次通过进入队列，hello5对应0位置，hello4对应1位置，hello3对应2位置，hello2对应3位置，hello1对应4位置:

![](https://a.a2k6.com/gerald/i/2024/07/03/kme3.png)

在这个入队过程中，队尾在朝前移动的 :  0 => 1 => 2 => 3 => 4  所以我们可以声明一个整型的变量记录队尾的位置:

```java
// capacity 是数组容量
int tail = 0;
```

计算下一个位置的公式就可以为: next  = (tail++) %  capacity ,  现在让我们考虑入队是指针迁移，出队就是指针后移，所以popBack方法首先获取当前头节点的位置，然后指针后移即可。现在我们可以写出下面的代码:

```java
public class FixMemoryQueue<T> {
    /**
     * 存储数据的泛型数组
     */
    private Object[] dataArray;

    /**
     * 记录头结点的位置
     */
    private int head;

    /**
     * 记录尾结点的位置
     */
    private int tail;
    /**
     * 记录队列存储了多少元素
     */
    private int size;

    private int capacity;

    public FixMemoryQueue(int capacity) {
        if (capacity <= 0) {
            throw new IllegalArgumentException();
        }
        this.capacity = capacity;
        this.head = 0;
        this.tail = 0;
        this.size = 0;
        dataArray = new Object[capacity];
    }


    public boolean pushBack(T t) {
        if (size == capacity) {
            return false;
        }
        dataArray[tail++ % capacity] = t;
        size++;
        return true;
    }

    public T popFront() {
        if (size == 0) {
            return null;
        }
        size--;
        return (T) dataArray[head++];
    }

    public int size() {
        return size;
    }
}
```

现在让我们从队头入队pushFront，队尾出popBack,  也就是说入队顺序是hello5、hello4、hello3、hello2、hello1, 出队顺序是hello1、hello2、hello3、hello4、hello5。也就是先进后出。

![](https://a.a2k6.com/gerald/i/2024/07/03/43o84.png)

入队的过程中头指针前移，这次是尾指针固定不动。 因此我们可以给出下面这两个方法:

```java
public  boolean pushFront(T t){
    if (size == capacity) {
        return false;
    }
    int next = (size ) % capacity;
    this.head = next;
    dataArray[next] = t;
    size++;
    return true;
}

public T popBack(){
    if (size == 0) {
        return null;
    }
    size--;
    return  (T) dataArray[head--];
}
```

注意到现在为止我们都保持了良好的操作对称性，即先进(pushBack)先出(popFront) , 先进(pushFront)后出(popBack)。现在让我们为这个队列加上一个限制词，我们希望他线程安全。

## 然后是线程安全

在《我们来聊聊线程安全吧》这一篇我们已经对线程安全进行了详细论述，虽然我们没有为线程安全找到一个形式化的定义，但是我们做到了工程化的回答，也就是说对于线程安全的集合来说， 我们要求以下三点:

1. 不能丢值：比如我们上面的队列，两个线程都向集合放值，集合可以容纳两个元素的时候，不应该出现丢值，在上面我们实现的队列中假设两个线程都添加一个，后操作的可能把先操作的覆盖掉。

​	![](https://a.a2k6.com/gerald/i/2024/07/03/4cmz.png)

2. 出现死循环，导致调用方无法接着往下执行。

3. 多个线程操作的时候应当像线程单独排队操作的效果，也就是隔离性，这也被称为一致性，在《我们来聊聊线程安全吧》这一篇里面我们已经讨论过这个弱一致性了，当时我对这个弱一致性的理解为，多个线程并发读写，多个读线程在什么时候看到的是一致的，由于CopyOnWriteArrayList的特性，每次操作的时候都会产生新的数组，所以如果多个读线程在写之前获得了迭代器，那么这些迭代器遍历出来的元素就是一样的。

   对于线程安全的集合我们不能靠集合的大小去遍历的原因在于，并发读写的时候，集合实际的大小是在变化的。但是线程安全的集合也需要迭代，因此线程安全的集合在遍历的时候，可以通过迭代器来遍历。下面是CopyOnWriteArrayList的源码:

```java
// CopyOnWriteArrayList的源码
public Iterator<E> iterator() {
    return new COWIterator<E>(getArray(), 0);
}
// 省略部分代码
static final class COWIterator<E> implements ListIterator<E> {
 /** Snapshot of the array */
 private final Object[] snapshot;
 /** Index of element to be returned by subsequent call to next.  */
 private int cursor;
    
 private COWIterator(Object[] elements, int initialCursor) {
      cursor = initialCursor;
      snapshot = elements;
  }
} 

```

![](https://a.a2k6.com/gerald/i/2024/07/03/30nz.png)

看CopyonWriteArrayList的设计思想的时候，我想到了MySQL的MVCC(Multi-Version Concurrency Control) 多版本并发控制，MySQL根据事务的隔离级别来决定是否给予查询者查看最新的数据，在对数据进行更改的时候，MySQL并不会直接操纵数据，而是会先将改变记录到undo log里面，同时在MySQL的行记录里面有多个隐藏列，涉及事务的有两个值得我们注意:

- trx_id： 每次一个事务对某条聚簇索引记录进行改动时，都会把该事务得到事务id赋值给trx_id隐藏列。

- roll_pointer: 每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo 日志中，然后这个隐藏列就相当于一个指针，可以通过它来记录修改前的信息。

![](https://a.a2k6.com/gerald/i/2024/07/04/45dh.png)







于是我认为ConcurrentHashMap应该也是这样，也生成一个快照，

在遍历Map的时候我们一般会这么写:





现在让我们来看ConcurrentHashMap 生成迭代器的时候:

```java
//  ConcurrentHashMap 源码
public Set<Map.Entry<K,V>> entrySet() {
    EntrySetView<K,V> es;
    return (es = entrySet) != null ? es : (entrySet = new EntrySetView<K,V>(this));
}
static final class EntrySetView<K,V> extends CollectionView<K,V,Map.Entry<K,V>>  implements Set<Map.Entry<K,V>>, java.io.Serializable {
  EntrySetView(ConcurrentHashMap<K,V> map) { super(map); }   
}
abstract static class CollectionView<K,V,E>  implements Collection<E>, java.io.Serializable {
        final ConcurrentHashMap<K,V> map;
    CollectionView(ConcurrentHashMap<K,V> map)  { this.map = map; }
}    
```

这里只是生成了一个新的EntrySetView对象存储生成

   



从操作上来说，一致性越强写法越简单，一致性越弱就写起来越复杂。

### 强一致



### 弱一致



#### 读写锁实现



#### 退避策略 + 乐观锁



## 测试样例





## 对比其他框架的实现







## 写在最后







## 参考资料

[1] LMAX Disruptor: High performance alternative to bounded queues for exchanging data between concurrent threads   https://lmax-exchange.github.io/disruptor/disruptor.html
