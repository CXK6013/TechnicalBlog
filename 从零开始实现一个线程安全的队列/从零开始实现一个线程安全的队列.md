# 当数组遇上队列: Java线程安全实现详解(一)

> 当你养成一种分析问题、琢磨文章的习惯之后，日积月累；你便会感到复杂的东西也是由少数几个大的部分组成的。这些部分出现的原因和它们之间的相互关系也是可以理解的。与此同时，由于读的东西多了，运算的技巧也高了，你会发现，一些复杂的推演过程大部分是由某些必然的步骤所组成，就比较容易抓住新的关键性的部分 ---  越民义

[TOC]

> 这是一个系列的文章，我们会逐步完善。用到什么讲什么。

## 前言

最近碰上个有趣的题目，用数组实现一个队列，要求线程安全，高性能。这个问题刚好能糅合一些对基础知识的运用，于是打算做一下，同时展开自己的思考过程。要求是递进式的，首先是用数组实现一个队列，队列的特点是先进先出，先进先出意味着我们要提供一个方法入队和出队方法:

- pushBack:  将元素放到队尾，如果队列满了，返回添加失败。
- popFront:   从队头开始出队 ，如果队列为空返回失败。

也可以是从队头入队，然后从队尾出队:

- pushFront: 队头入队   如果队列满了，返回添加失败
- popBack:  队尾出队

![](https://a.a2k6.com/gerald/i/2024/06/29/7ixxv.jpg)

有时候我们也希望知道这个队列实际存储了几个元素:

- size方法: 返回了队列实际存储了多少个元素

## 首先用数组实现队列

有了设计目标就可以着手编写代码了，在Java里面首先我们需要一个类，类里面存放数据和行为, 为了让我们的队列更通用一些，我们将为我们的队列引入泛型支持，但是在Java中无法实现泛型数组的语法，也就是下面这样:

```java
T[] array = new T[5];
```

回顾ArrayList的实现你会发现，ArrayList实现泛型化，底层仍然是一个Object数组，然后在get的时候，做了强制类型转换

```java
public E get(int index) {
    rangeCheck(index);
    return elementData(index);
}
```

```java
@SuppressWarnings("unchecked")
E elementData(int index) {
    return (E) elementData[index];
}
```

所以我们也是用这样的思路来解决类型转换问题。解决完泛型问题，我们来设计pushBack方法，这个方法的设计目标是将请求入队的元素放在队尾，如果我们基于引用实现，在类里面我们可以放一个尾节点(指针)指向最后一个节点。用数组实现的时候我们存储的就是尾节点的下标了，在一开始队列初始化的时候尾结点和头节点可以都指向0下标，于是我们就需要有一个方法计算出来我们的元素应该放在哪个位置，我们自然就想到了取余，如果我们有五个元素要入队，用pushBack入队顺序为0、1、2、3、4.

![](https://a.a2k6.com/gerald/i/2024/06/29/7fc0g.jpg)

头插法的入队顺序4、3、2、1、0。观察规律:

- 5 %  5  =    0
- 5 /  4     1 
- 5  % 3     余数为 2
- 5 % 2      余数为 3

- 5 % 1



对尾插法，x = (x + 1) % 5 , x 初始值为0,  对这个函数进行迭代就可以得到从队尾入队的数组下标。 而对于从对头入队，注意观察此时x的取值是5,4,3,2,1，我们联想到5刚好是数组的容量，所以对于尾插法的取值应当是 x  = (capacity  -  x) % 5, x的初始值为0，capacity  为数组容量，由此我们就得到了两个入队公式。现在让我们考虑出队, 从队尾出队，我们就需要一个记录尾结点的位置，出队的时候尾结点迁移，我们也可以考虑从队头出队，同样我们需要一个头结点记录头结点的位置。

现在让我们考虑一般先进先出的队列，让我们来实现入队出队方法，也就是pushBack和popBack, 所以这个类里面我们首先要有一个Object数组，有一个capacity 来指定容量，一个size属性记录实际存储的元素大小，一个head和tail属性存储头结点和尾节点在哪个位置。







## 然后是线程安全

在《我们来聊聊线程安全吧》这一篇我们已经对线程安全进行了详细论述，虽然我们没有为线程安全找到一个形式化的定义，但是我们做到了工程化的回答，也就是说线程安全

### 强一致



### 弱一致



## 测试样例





## 对比其他框架的实现







## 写在最后







## 参考资料

[1] LMAX Disruptor: High performance alternative to bounded queues for exchanging data between concurrent threads   https://lmax-exchange.github.io/disruptor/disruptor.html