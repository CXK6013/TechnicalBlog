# 复习大纲

如何扣减库存: 1.=> 利用数据库的锁   几千个基本就卡住。 对数据

缓存 DB一致性： 

1. Redis数据直接异步更新至数据库。 数据库同步刷新到缓存。 redis宕机或者故障，可能会造成缓存内库存数据的丢失。
2. Redis 扣减库存，插入扣减明细，同步在业务数据中插入库存信息，插入成功，库存扣减，扣减成功，更新数据库。

首先在两种存储介质之中，一定，存在时间差，我们要做的就是将这个时间差压缩。

先更新数据库 、后更新缓存

update 库存-1

更新数据库

考虑极端场景:  假设A线程扣减库存到 99， B线程扣减库存到98，这个时候B线程晚于A线程去更新数据库，则出现库存和数据库更新不一致。这个不一致只能等到

先更新缓存 、后更新数据库   先更新缓存后更新数据库，问题在于更新数据库失败不能做到全部回滚。 除此之外还要考虑这样一个场景:

1. updateRedis
2. 更新数据库

A  写请求先更新缓存为0，

B 写请求先更新缓存为 1

更新数据的时候 A先于B，现在数据库倒是不正确了。 这种策略应该被我们避免采用

更新数据库前删除缓存:  这样即使更新数据库失败，缓存是和数据库保持一致的。

但是写写请求，就会有点问题，缓存失效的时候，另一个写请求去读数据库的值，然后读到了100，这也造成了数据库和缓存不一致。 由此引出延迟双删。

更新数据库之后删除缓存: 

- 针对大部分读多写少场景，建议选择更新数据库后删除的策略
- 针对读写相当或者写多读少的场景，建议选择更新数据库后更新缓存的策略

用RocketMQ + binlog兜底

ElasticSearch看一个倒排索引吧: 

数据库索引: hash索引、B tree索引有点

B-树和B+树最主要的区别在于非叶子结点是否存储数据，

- B树: 非叶子节点和叶子节点都会存储数据
- B+树: 只有叶子结点才会存储数据，非叶子节点存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点之间形成了一个有序的双向链表。

B+树是B-树的一个变体，适应SSD。

RocketMQ: 

分布式系统调用的特点为一个核心业务逻辑的执行，同时需要调用多个下游业务进行处理。因此，如何保证核心业务和多个下游业务的执行结果完全一致，是分布式事务需要解决的主要问题。

缓存雪崩







Redis常见的数据库结构

Redis两种持久化机制特点:

RocketMQ的事务消息:  分布式事务消息 延迟消息

何以线程安全:

CHM 与 CopyOnWriteArrayList：

Netty：流水线面试题

JVM  CMS  ParOld ZGC G1







结构化思维

工程化思维

产品化思维







