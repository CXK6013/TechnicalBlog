# AQS学习笔记

```java
AbstractQueuedSynchronizer
```

## 作用

实现公平锁与非公平锁，将线程入队，避免线程自选，频繁获取CPU。

- 偏向锁

  > 如果当前线程ID与markword存储的不相等，则CAS尝试更换线程ID，CAS失败则升级为轻量级锁。

- 轻量级锁

  > 实际上也是通过CAS来抢占锁资源，多了从 Mark Word到Lock Record的过程



## 锁升级过程

## synchronized 像时汽车中的自动档，锁升级顺序: 无锁->偏向锁->轻量级锁->重量级锁。

初次执行到synchronized代码块的时候，锁对象会变成偏向锁(通过CAS修改对象头里的锁标志位)

字面意思时"偏向于第一个获得它的线程"。

当第二次到达同步代码时，线程会判断此时持有锁的线程是否时自己。持有锁的线程ID也在对象头里。

如果是则正常往下执行。由于之前没有释放锁，这里就不需要重新枷锁。

如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。

一旦有第二个线程加入竞争，偏向锁就升级为轻量级锁（自选锁）。

锁竞争: 如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那就不存在锁竞争。

只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放。这才发生了锁竞争。

在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断是否能够成功被获取。

# 需求评审





