# 我们来聊聊JMM吧

> JMM ， Java Memory Model 这个相关的概念我们已经在《Java多线程学习笔记(一) 初遇篇》已经简单介绍过了，在这篇文章是从计算机的存储系统引出缓存不一致、处理器优化、指令重排序。引出原子性、可见性、有序性的。里面已经暗含了JMM了，但是没指明，这篇我们来细致的探讨一下JMM。

[TOC]

## 为什么要有JMM？

对于Java程序员来说，JVM真的是默默的做了很多，颇像老父亲一样，Java程序员不需要当前计算机的CPU架构有多了解，就能写出跨平台程序，毕竟选中Java，在某种程度上也是看中了Java的跨平台能力。当单核能力提升到顶的时候，CPU厂商选择了集成多核来提升CPU的计算能力，但是也不是核心越多，计算能力就越强，想起大学时代的联发科，手机上的SOC做到了十核心，但是计算能力确不如更少核心的高通骁龙芯片。但通过提升核心数来提升CPU的计算能力是一个方向，但是在计算机世界里面，往往解决一个问题，就会引入新的问题。接下来让我们看下多核世界的挑战。

### 多核的世界

处理器的速度是相当快的，处理器常常觉得主内存的读写数据的速度太慢，为了弥补处理器与主内存处理能力之间的鸿沟，硬件设计者在主内存和处理器之间引入了缓存(Cache)。现代的处理器一般有三级缓存，现代计算机的存储系统一般如下图所示:

![现代计算机存取结构](http://tva4.sinaimg.cn/large/006e5UvNly1h57gq3xhmdj311r0lggmt.jpg)

CPU直接与之打交道的是缓存,CPU通过缓存来读写数据:

![更为抽象的存储架构](http://tva2.sinaimg.cn/large/006e5UvNly1h57h11zcfaj30sn0hvgmh.jpg)

多个线程并发访问同一个共享变量的时候，这些线程对应的执行处理器上的高速缓存都会保留一份该共享变量的副本，这就带来一个新的问题-一个处理器对其副本数据进行更新之后，其他处理器如何“察觉”到该更新并做出适当反应，以确保这些数据后续读取该共享变量时能够读取到这个更新。这也就是缓存一致性问题，其实质就是如何防止读脏数据和丢失更新的问题，为了解决这个问题，处理器之间就需要一种通信机制，也就是缓存一致性协议。

### 缓存一致性协议

MESI(Modified-Exclusive-Shared-Invalid)协议是一种广为使用的缓存一致性协议，x86处理器所使用的缓存一致性协议就是基于MESI协议的。MESI协议对内存数据访问的控制类似于读写锁，它使得对同一地址的读内存操作是并发的，而针对同一地址的写操作是独占的，即针对同一内存地址进行的写操作在任意一个时刻只能够由一个处理器执行。在MESI协议中，一个处理往内存中写数据时必须持有该数据的所有权。

###  写缓冲器与无效化队列





## 所以JMM 是什么？



