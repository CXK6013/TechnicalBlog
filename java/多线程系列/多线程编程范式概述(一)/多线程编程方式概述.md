# 多线程编程范式之线程协作范式

[TOC]

## 前言

前面的文章中我们已经将Java中多线程相关的概念介绍了七七八八了:

- 《当我们说起多线程与高并发时》
- 《Java多线程学习笔记(一) 初遇篇》

- 《Java多线程学习笔记(二) 相识篇》
- 《Java多线程学习笔记(三) 甚欢篇》
- 《Java多线程学习笔记(四) 久处不厌》
- 《Java多线程学习笔记(五) 长乐无极》
- 《 ThreadLocal学习笔记》

《当我们说起多线程与高并发》这篇的主题是讲清楚多线程和高并发的关系，粗略的说，在Java的Web场景下，选择Tomcat作为Servlet容器，用户向服务器的应用发起一个请求，首先经过操作系统，再接着经过Tomcat的侦听线程，请求的数据到达完毕，由侦听线程将这个请求送入线程池，线程池中的线程领取任务，根据URI, 调起对应的Servlet。

![request-response](http://tva2.sinaimg.cn/large/006e5UvNgy1h75tx1v9lhj30zo0ha74d.jpg)

所以在大量请求到达Tomcat，Tomcat的线程池会有大量线程活跃，这也就是高并发。那为什么要引入多线程呢，不少博客都会告诉你，是为了更有效的利用CPU的资源，但这个答案并不那么正确，原因在于开进程也可以做并发，毕竟线程在某些平台上就是轻量级的线程，从操作系统的角度来说，引入多线程是为了更有效的共享资源，毕竟都在一个地址空间内，更为方便。在软件开发领域，我们引入一种机制来解决原先的问题，但是往往是原先的问题被解决之后，这种机制又会带来新的问题，这也就是《Java多线程学习笔记(一) 初遇篇》所探讨的问题，在这篇中我们以多线程卖票为例: 

```java
public class TicketSell implements Runnable {
    // 总共一百张票
    private int total = 2000;
    @Override
    public void run() {
        while (total > 0) {
            System.out.println(Thread.currentThread().getName() + "正在售卖:" + total--);
        }
    }
}
 public static void main(String[] args) {
        TicketSell ticketSell = new TicketSell();
        Thread a =  new Thread(ticketSell, "a");
        Thread b = new Thread(ticketSell, "b");
        a.start(); // 调用操作系统提供的线程接口 启动线程并执行TicketSell的run方法 启动的线程我们命名为a线程
        b.start(); // 调用操作系统提供的线程接口 启动线程并执行TicketSell的run方法 启动的线程我们命名为b线程
 }
```

发现多线程会出现一票多卖这样的现象，原因在于线程并发执行的，可能在a线程刚将total加载进自己的内存，然后时间片耗尽，b线程也进来。然后就出现了一张票重复卖的现象。为了避免这种现象，我们自然想到如果有办法能够做到a线程进入之后打上个标记，b线程进来之后发现有标记，就知道a线程还没做完对应的操作，需要自己进行等待，这也就是Java平台的锁，Java平台的锁大致分为两类: 

- 乐观锁: 原子工具类  也称轻量级锁
- 悲观锁: synchronized   ReentrantLock

我们上面说的b线程在执行run方法，发现上面有a线程的标记，自己陷入等待的就属于悲观锁策略。那乐观锁是用来干什么的？ 我们再来分析一下上面的问题，看看是什么原因造成的？ total--并非原子操作，对应的指令其实分为三步:

- 先将total加载进线程的工作内存

- 然后total = total - 1
- 写到主内存

但如果我们将这些做成原子操作呢，其实还会有问题，原因在于while语句的判断就率先将total加载进工作内存，所以还是会发生多卖。那如果在执行对total的写之前的时候，先判断一下线程内部存储的内存和主内存是否相等，也就是total递减操作之前的，如果相当代表这个变量还没被动过，那就执行更新操作。如果主内存的变量并不相等代表已经被人修改过了，所以这里要再读取以下主内存的变量，再进行递减操作。如果再不相等，再加载内存。等价于下面的操作: 

```java
do{
    int oldValue = count;
    int newValue = count + 1;
}while(!compareAndSwapInt(oldValue,newValue))
```

compareAndSwapInt比较并交换，那么该如何保障上面的代码是原子性的呢，保障原子性的话，我们就要请求操作系统，写JNI，什么是JNI，也就是java native intreface, 即Java调用C，但是你不用担心Java有现成的封装好的类，你可以拿来直接用, 这些类位于java.util.concurrent.atomic这个包下面:

![JUC工具类](http://tva2.sinaimg.cn/large/006e5UvNgy1h75wwi2k14j30bn0b63z6.jpg)

乐观锁是要比悲观锁轻量级一些的，原因在于悲观锁有线程唤醒的成本，线程沉睡和唤醒都要请求操作系统。但是也并不意味着完美无缺，如果大量线程调用，重试次数就可能变多，从而会占用大量CPU的资源，软件的世界里面还是没有银弹(银弹:完美无缺的工具)。注意我们上面的假设是旧值与内存中的值相同即认为这个变量还没有被更新过，我们将变量更新进主内存，但这种假设会总是对的吗？我们上面的假设在于值相同即被视为当前变量没被修改过，这里我们假定A线程在做原子操作的时候加载进自己的工作内存是A，A线程的目标是将共享变量修改为C，A线程在将C写入主内存的时候，发现主内存的变量是B(假定有线程将共享变量修改为B)，更新变量失败，但是这个时候操作系统分配给A线程的时间片耗尽，这个时候C线程的目标是将B改为A，刚好改动成功。此时A再加载从主内存加载变量的时候是A，主内存中存储的变量也是A，但是我们明显发现，此时我们的假设“值相同”=值没被改变过是不成立的，举个例子，小A和小B为了避免过度消费，选择将优惠券放在一个保险箱里，然后这个保险箱很特殊，只能有一个人打开。但是半夜的时候两人不约而同都想去买买买，小A先打开保险箱，将消费券拿出，然后将保险箱关闭，恰巧碰见小B来，小B看到了保险箱没被打开，于是认定保险箱的消费券还在。 现实生活中的人当然不会这么认定，原因在于在我们的意识里认定在这种情况下保险箱我之前看到的一样是关着的里面的消费券等于没动是不成立的。

这也就是ABA问题，但并不是CAS的问题，是这种先验假设的问题，如果我们关心的是值发生了修改，那我们就不能用那种先验假设，或者我们需要为我们的先验假设打上一个补丁，即为共享变量的值补充上一个修订号，每次更新都会将这个修订号加一，只有变量和修订号都相等，我们才认为共享变量为发生更新。

但其实我们上面的模型还是有一定的问题，我们用了主内存这个词，好像CPU内部没有缓存一样，真实的计算机文件系统如下图所示: 

![文件系统](http://tvax2.sinaimg.cn/large/006e5UvNgy1h75z8p88yij30kc0cbtad.jpg)



那我们上面说的刷新内存值是CPU将值直接更新到主内存里？ 这显然不大可能，尽管主内存的读写速度已经很快了，但在CPU看来还是不够快，CPU为了速度可能会将变量分配到寄存器进行存储，多核CPU的寄存器是隔开的，一个CPU的对共享变量的更新可能只是更新到该处理器的写缓冲器中，还未到达共享的三级缓存中，而写缓冲器也是私有的，所以就算更新完成，另一个CPU核心从高速缓存中读取到的值还可能是过时的值。下图是CPU的工作模型: 

![多核心](http://tva2.sinaimg.cn/large/006e5UvNgy1h75zwzfriej31240gpjrm.jpg)





更为极端一点，就算是此时的更新变量已经到达高速缓存，并向其他CPU核心发送了更新通知，那么另一个CPU接收到通知也可能选择不从高速缓存中加载最新的变量，而会选择将这个通知放在无效化队列里，这也就导致了该CPU读到的是一个过时的值。

虽然一个处理器的告诉缓存中的内容不能被另外一个处理器直接读取，但是一个处理器可以通过缓存一致性协议来读取其他处理器告诉缓存中的数据，并将读到数据更新到该处理的高速缓存中。这种一个处理器从其自身的处理器缓存以外的存储部件中读取数据并将其更新到该处理器缓存的过程，我们称之为缓存同步。相应地，我们称这些存储部件的内容是可同步的，这些存储部件包括处理器的高速缓存、主内存。那在Java中我们该使用这种缓存一致性协议呢？ 其实很简单在对应的共享变量上加上volatile关键字就行。 其实



线程池核心数



这里引出JMM  happens-before

我们来聊聊锁升级

Future接口 Callable接口

这里引出ThreadPoolExecutor  ForkJoinPool   









## 参考资料

- 什么是ABA问题？ https://www.zhihu.com/question/23281499
- 真实业务场景展现CAS原理的ABA问题及解决方案  https://blog.csdn.net/cauchy6317/article/details/120475452
