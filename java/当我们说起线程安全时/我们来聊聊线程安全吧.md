# 我们来聊聊线程安全吧

[TOC]

## 缘起

之前在知乎看到一个问题，京东一面：为什么 HashMap 是线程不安全的？看到这个问题我的第一个反应是，什么是线程安全，我还是饶有兴致的向我自己提问，然后期待一个像是数学定义一样的答案。那么什么是线程?  从操作系统的角度来看，为了实现任务并发，提高CPU的使用率，我们引入了进程，一个执行的程序在等待资源的时候，我们完全可以让CPU干点别的活，于是进程出现了，进程是动态的，程序是静态的，执行中的程序就叫进程，当一个程序开始执行，操作系统需要向他分配内存资源，这么一看进程可以看做是执行逻辑和资源的结合体，像是下面这样:

![](https://a.a2k6.com/gerald/i/2023/10/31/5fje4.png)



但是随着发展，程序开始集成越来越多的功能，像是一个音乐播放器，在最开始只具备打开本地文件播放的能力，慢慢的可以实现在线播放，在线播放，在线播放事实上分成三个动作，下载，解压，播放，由于我们目前只实现了进程级别的并发，那将这三个动作拆分到不同的进程里面，那不同的进程共享资源其实是一个麻烦的问题，那能不能简单点，这三个功能本身就算在这个进程里面，实现进程内部执行单元的切换。

![](https://a.a2k6.com/gerald/i/2023/11/12/xi7h.jpg)

当然可以，那么该如何实现呢，已知是现在有进程，那么一种选择就是将原来的进程改造的轻量级一些,  然后还能共享地址空间和其他资源，以前的进程概念用于刻画执行中的程序，那么改造之后的轻量级进程则用户刻画程序内部的执行流，所以这就是线程嘛，某种程度上我们可以将其当做内核级别的线程实现，但与最初的线程有着一点区别，早期的Linux事实上只支持用户态的线程，也就是说进程内部线程的切换是由进程内部来控制的，这对于早期的开发者来说是一个挑战，说起这个，你想到了什么，有没有想到Java的线程模型，早期Java的线程被称为绿色线程，线程的切换依赖于JVM，采用这一模型的原因在于Java出生于1996年，1997年，JDK 1.1 发布，而在工业界的第一款双核CPU于2001年发布，这款CPU来自于IBM，名叫 Power 4，我们可以认为在Java刚出生的年代还是单核处理器的天下，而在单核处理器下面绿色线程的性能是要更好的，虽然这对开发者不大友好，自己实现一套线程切换调度。所以早期的线程就是用户态的线程，只是为了更加强大的并发，更加友好的体验，更方便的共享资源，但是很快单核心的处理器遇到了瓶颈，处理器晶体管越多、频率越高，越无法稳定运行，同时发热量越大，高频产生的高温需要更极端的散热系统。所以，频率提升不上去了。所以欢迎光临多核时代，所以我们需要更加充分的利用多个核心，由此Linux就推出了线程的轻量级进程实现，这也就是原生线程，原先归虚拟环境调度的多线程被移动到了操作系统身上，对于开发者来说多线程切换更加容易，也能够更加充分的利用多核心，这也是Java改动线程模型的原因，适应多核时代。

当我问我自己什么是线程的时候，我当即给出的答案是一个独立的执行单元，我的回答想来是从Linux线程的实现来说的，这么说似乎也没什么问题，从调度程序的角度来说也只考虑进程，但是从用户角度来说，线程通常是要依附于进程，这么说线程是独立的执行单元也似乎有些问题。那一个目前可以接受的答案是线程是进程内部的一个执行流，进程是正在执行中的程序，有了线程之后，我们就可以将进程看成资源与若干执行流的结合体。我们的目标就是给出线程安全的一个定义，给出一个充分必要条件，像下面这样:

> 线性方程组有解的充分必要条件是其系数矩阵的秩等于其增广矩阵的秩

但也许这是一厢情愿，一切问题并非是数学问题， 我想起数学的公理化，那什么是公理化，粗略的说就是给定一组最基础的公理，在这个基础上推导出这个领域的定理，像是欧几里得几何，严谨一点的说法是:

> **公理化**是数学中一种思想方法, 即对某个 (可能来源于直观或者其它理论的) 研究对象, 找出其中的一些基本对象并列举出想让这些对象满足的一些关系. 这些关系称为**公理**, 对象和关系全体称为**公理系统**. 之后在建立理论时, 不去管这些公理为何成立, 且只使用这些公理而不借助于其它理论来推导.

我想起杨振宁公理化的论述:

> 到20世纪初，有很多人试图将热力学公理化。我认为这不是一个很有用的东西。物理学是关于现实的，而现实是非常复杂的，它不像欧几里德几何那样可以被公理化。如果你真的想要绝对合乎逻辑，你必须在完全确定之前陈述很多很多事情。所以，在我看来，公理化物理学的想法是没有用的。之所以有公理化热力学的讨论，是由于在数学发展到了十九世纪末二十世纪初的时候，出现了将数学公理化的想法，大数学家希尔伯特的厥功至伟。希尔伯特在1900年就23个重要的数学问题发表了著名的演讲，对20世纪的数学产生了巨大的影响。这23个问题中，有一个是将物理学公理化。在我看来，这不是正确的方向。大约在1930年，一位名叫哥德尔的年轻数学家证明，将整个数学公理化的想法并不是完全正确的事情，这导致了数学、数理逻辑和哲学的伟大进步。然后，在没有实现物理公理化的情况下，人们对这个希尔伯特问题失去了兴趣，直到1950年代。20世纪50年代，基本粒子物理学进入了一个探索未来的时期，一些人，尤其是德国的很多人，在某种意义上复兴了这种公理化物理学的想法。当时国际上有许多人去跟风，发展出来一个叫作公理化场论的领域，但是到了1970年代，这个领域也走到了尽头。今天，在这样的方向上进行这种努力并不被认为是推动物理学向前发展的有用尝试。我们在讨论物理学时应当努力成为物理学家而不是逻辑学家。

所以我们本篇的目标，对什么是线程安全做出回答，给出一个数学定义一样的答案，也许根本就做不到，原因在于这个问题也许就没有答案，我们不该用这样的方式对这个问题作出解答，问题的答案可能是另一种形式，但这不意味着探索失去了意义，我们可以给出一个近似的答案，可以让我们在考察线程安全问题时更加得心应手，毕竟造火箭的时候，可能还是让你写一个线程安全的集合的，要回答这个问题，我们至少心里有一个线程安全的定义，定义是充分必要条件的另一种陈述。

那什么是安全，其实提到这个词，我想到的是交通安全，所谓交通安全我想指的就是行动的人正常到达目的地，没有因为违法规则，而出事故。那什么是安全？  在现代汉语词典中，安全的语义为：没有危险；不受威胁；不出事故。 在剑桥英文词典中safe的语义也类似:

> not in danger or likely to be harmed

也就是说这个词的语义是借助其他词的否定来定义的，那线程安全呢，我们首先要考察是在什么情况下会出现安全问题？ 然后通过这些现象给线程安全一个定义。

## 什么情况会出现线程安全问题？

之前在微信群里面看聊天，有个朋友说单核心就不会出现线程安全问题了，当时觉得这个结论蛮有意思的，因为按照我的理解从CPU调度上来说，CPU调度器都是从就绪队列中选择一个进程(在Linux下并不区分线程与进程，线程的真正实现是轻量级进程，所以这里用了线程这个词)进行执行，多个核心也就是可以理解为多个执行者，回想一下在《 Java多线程学习笔记(一) 初遇篇》中我们引出线程安全的例子:

```java
public class TicketSell implements Runnable {
    // 总共一百张票
    private int total = 2000;
    @Override
    public void run() {
        while (total > 0) {
            System.out.println(Thread.currentThread().getName() + "正在售卖:" + total--);
        }
    }
}
public static void main(String[] args) {
   TicketSell ticketSell = new TicketSell();
   Thread a =  new Thread(ticketSell, "a");
   Thread b = new Thread(ticketSell, "b");
   a.start();
   b.start();
}
```

当时引出这里有线程安全问题说的是出现两个线程卖了同一张票，那这是为什么呢？ 让我们回忆一下《JMM学习笔记(二) 规则和volatile》中的内容:

> Java内存模型给出了一组规则或规范， 定义了程序中各个变量(包括示例字段，静态字段和构成数组对象的元素)的访问方式，规范了Java虚拟机与计算机内存是如何协同工作的，JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些文献也称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都必须存储在内存，主内存是共享内存区域，所有线程可以访问，但线程对遍历的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对遍历进行操作，操作完成后再将变量写会主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝。工作内存是每个线程的私有数据区域，因此不同的线程无法访问对方的工作内存，线程间的通信(传值) 必读通过主内存来完成

所以出现一张票重复卖的原因是自减操作并不是一个原子操作，不是原子操作的原因就是可以被打断，total--涉及两个操作首先从主内存中读取total，然后自减，那么某线程时间片耗尽，没来得及完成自减操作，也就是没来得及将操作之后的值刷新会主内存，然后另一个线程时间片获得执行，从主内存中读取到total的值，然后做自减操作，这样的情况下就会导致会卖出一张相同的票。

当时引出这个例子的时候还做了声明，不能保证相同的结果，今天再看这个例子的时候，感觉还是有些不直观于是我将TicketSell做了改造:

```java
public class TicketSell implements Runnable{
    
    private Integer total = 2000;
    
    private Map<Integer,String> map = new ConcurrentHashMap<>();

    @Override
    public void run() {
       while (total > 0) {
            Integer result = total--;       
            String absentThreadName = map.putIfAbsent(result, Thread.currentThread().getName());
            if (absentThreadName != null){
                System.out.println(absentThreadName + "和" +  Thread.currentThread().getName() + "卖了同一张票");
            }
            System.out.println(Thread.currentThread().getName() + "正在售卖:" + result);
    }
}
```

然后还是没跑出来，似乎验证多线程的行为破有些不可测的感觉，但是还记得《JMM测试利器-JCStress学习笔记》吗，我们就JCStress来测试原子性，工欲善其事，必先利其器。

```java
// These are the test outcomes.
@Outcome(id = "1, 1", expect = ACCEPTABLE_INTERESTING, desc = "Both actors came up with the same value: atomicity failure.")
@Outcome(id = "1, 2", expect = ACCEPTABLE, desc = "actor1 incremented, then actor2.")
@Outcome(id = "2, 1", expect = ACCEPTABLE, desc = "actor2 incremented, then actor1.")
// This is a state object
@State
public class API_01_Simple {

    int v;

    @Actor
    public void actor1(II_Result r) {
        r.r1 = ++v; // record result from actor1 to field r1
    }

    @Actor
    public void actor2(II_Result r) {
        r.r2 = ++v; // record result from actor2 to field r2
    }
}
```

跑出来的结果:

![](https://a.a2k6.com/gerald/i/2023/11/12/nyns.jpg)

很轻松就跑出来了递增相同的值，这个例子不安全的原因在于对共享变量的操作并非是原子性的，导致更新的结果可能不能及时刷新回主存，导致其他线程可能读到的是相对旧值，那么解决的方式比较简单，一个是加锁，等操作完成再让其他线程对共享变量进行操作，这在某种程度上就是将并行变成排队执行的感觉，所以这会影响性能，所以我们在使用锁的时候就需要尽可能的缩小锁的粒度，尽可能的保证不是排队执行。另一种方式是将对共享变量的操作变成原子的，同时使用CAS策略，也就是说再将更新后的结果刷新到主内存的时候，比较提供的变量值和主存的变量是否相等，如果相等代表主存的变量还没有被更新，然后将更新过后工作内存的变量更新到主存里面：

![](https://a.a2k6.com/gerald/i/2023/11/12/3qrb.jpg)

这也就是Java中原子类做的事情，我们以AtomicInteger为例进行解读:

```java
public final int getAndDecrement() {
   return U.getAndAddInt(this, VALUE, -1);
}
@HotSpotIntrinsicCandidate
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
       // 读取这个值,比较并交换.这个方法返回的是操作之前的值 
       v = getIntVolatile(o, offset);
    } while (!weakCompareAndSetInt(o, offset, v, v + delta));
    return v;
 }
```

那么单看TicketSell，其实多线程跑也没什么问题，并没有造成线程死锁，我们认为线程不安全的原因仅仅是因为递减操作不是原子的，导致卖出了同一张票，或者再本质一些就是由于线程对共享变量的操作没有及时被刷新到工作内存中，或者说线程读到了旧值。所以从这个例子中我们提炼出来的一个线程安全要以就是线程操作的变量应当是最新的，其他线程对共享的变量应当及时的能够刷新到其他线程上。上面的例子中我们提到用悲观锁可以解决一张票被售出多次这个问题，因为悲观锁就像是排队对共享变量进行操作一样，那么是否用了悲观锁就能保证线程安全, 答案当然不是，一个有效的反驳例子是单例模式的DCL写法:

```java
public class SimpleSingleTon {
    private static SimpleSingleTon singleton = null;
    private SimpleSingleTon(){
    }
public static  SimpleSingleTon getInstance(){
     if (singleton == null){
      	 synchronized(SimpleSingleTon.class){           
     		 singleton = new SimpleSingleTon();
    	}
      }
     return singleton;
 }
public static void main(String[] args){
   	  new Thread(()-> System.out.println(SimpleSingleTon.getInstance())).start();
      new Thread(()-> System.out.println(SimpleSingleTon.getInstance())).start();
      new Thread(()-> System.out.println(SimpleSingleTon.getInstance())).start();
      new Thread(()-> System.out.println(SimpleSingleTon.getInstance())).start();
    }
}  
```

这个例子基本运行都没有问题，但从理论上来说确实有问题的，原因在于new 对象这个步骤，并不是原子的，可以大致分成三个步骤:

1. 分配SimpleSingleTon所需的内存空间，并获得一个对该内存空间的引用，
2. 调用SimpleSingleTon类构造器初始化1获得的内存空间
3. 将1获得对内存空的引用赋值给singleton

如果操作有依赖关系，编译器不会乱序执行操作， 但是上面的三个步骤，1=>3=>2和1=>2=>3的效果是相同的，所以JIT编译器在一些情况下就会进行重排，那么在这个情况下，如果是1=>3=>2，给外部调用者拿到的就是一个未初始化完成的对象，就会产生意想不到的后果，为了避免这种情况的产生，也就是禁止指令重排，我们可以在变量上面加上volatile 来告诉编译器。那么来看就算是将任务让线程排队执行，也无法保证线程安全，那么接着需要补充线程安全的语义，为我们的线程安全定义打上补丁，除了保证线程对共享变量的操作能够及时的被其他线程看到，还要保证其他线程拿到的共享变量是完整的。这里我们总结的一些共性就是所有的线程安全问题都牵扯到共享变量。我们接着考察线程安全的集合HashTable、ConcurrentHashMap、CopyOnWriteArrayList，对比这三个集合是如何实现线程安全的，我们首先分析多线程操纵集合会有什么问题，我们希望达到的，再来考察这些集合采用的手段。让我们从HashTable入手，为什么先从HashTable入手，因为HashTable相对比较简单，那你是从哪里知道这个集合是线程安全的，当然是从HashTable上的注释看到的:

> As of the Java 2 platform v1.2, this class was retrofitted to implement the Map interface, making it a member of the Java Collections Framework. 
>
> 自JDK 1.2，这个类被改造为Map接口的实现者，使他称为Java集合框架的一员。
>
> Unlike the new collection implementations, Hashtable is synchronized. If a thread-safe implementation is not needed, it is recommended to use HashMap in place of Hashtable. 
>
> 与新的集合实现不同，HashTable是同步的，如果不需要线程安全的实现，推荐使用HashMap。
>
> If a thread-safe highly-concurrent implementation is desired, then it is recommended to use java.util.concurrent.ConcurrentHashMap in place of Hashtable. 如果需要线程安全的高性能实现，推荐使用ConcurrentHashMap 。

那HashTable想来在JDK的开发人员中一定是线程安全的了， 我们来观察一下这个类的实现，首先HashTable是一个动态集合，所谓动态集合就是当集合装不下的时候会自动扩容，对于集合，我们首先关注的就是存(put)和取(get)：

```java
public synchronized V put(K key, V value) {
    // Make sure the value is not null
    if (value == null) {
        throw new NullPointerException();
    }

    // Makes sure the key is not already in the hashtable.
    Entry<?,?> tab[] = table;
    int hash = key.hashCode();
    int index = (hash & 0x7FFFFFFF) % tab.length;
    @SuppressWarnings("unchecked")
    Entry<K,V> entry = (Entry<K,V>)tab[index];
    for(; entry != null ; entry = entry.next) {
        if ((entry.hash == hash) && entry.key.equals(key)) {
            V old = entry.value;
            entry.value = value;
            return old;
        }
    }
    addEntry(hash, key, value, index);
    return null;
}
```

```
public synchronized V get(Object key) {
    Entry<?,?> tab[] = table;
    int hash = key.hashCode();
    int index = (hash & 0x7FFFFFFF) % tab.length;
    for (Entry<?,?> e = tab[index] ; e != null ; e = e.next) {
        if ((e.hash == hash) && e.key.equals(key)) {
            return (V)e.value;
        }
    }
    return null;
}
```



这里讨论到ConcurrentHashMap，然后再引出到CopyOnWriteArrayList，



## 参考资料

[1] 论文学习之 Linux 调度器  https://juejin.cn/post/7228886005071364157

[2] 《Understanding the LINUX  KERNEL》 third  edition https://www.cs.utexas.edu/~rossbach/cs380p/papers/ulk3.pdf

[3] Light-weight process https://en.wikipedia.org/wiki/Light-weight_process

[4] What is the difference between lightweight process and thread?  https://stackoverflow.com/questions/10484355/what-is-the-difference-between-lightweight-process-and-thread

[5] What are Linux Processes, Threads, Light Weight Processes, and Process State  https://www.thegeekstuff.com/2013/11/linux-process-and-threads/

[6] Why aren't Java threads both lightweight (like green threads) and multi-core capable? (backed by an internal native fixed size native thread pool)  https://stackoverflow.com/questions/67337772/why-arent-java-threads-both-lightweight-like-green-threads-and-multi-core-cap

[7] linux 线程  https://lishiwen4.github.io/linux/linux-thread

[8] 计算机体系结构基础 https://foxsen.github.io/archbase/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%84.html

[9] 为什么十多年前的奔腾4处理器主频就已经3G了，现在处理器还是3G，为什么处理器频率这么多年都没有提高？ 

[10] 物理公理化 https://m.thepaper.cn/newsDetail_forward_23677626

[11] 公理化 https://www.bananaspace.org/wiki/%E5%85%AC%E7%90%86%E5%8C%96

[12] CPU Scheduling https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/6_CPU_Scheduling.html

[13] Java多线程学习笔记(一) 初遇篇 https://segmentfault.com/a/1190000038318608#item-3

[14] JMM学习笔记(二) 规则和volatile  https://juejin.cn/post/7242918609856577591

[15] Why is i++ not atomic?  https://stackoverflow.com/questions/25168062/why-is-i-not-atomic

[16] What is the difference between ++i and i++? https://stackoverflow.com/questions/24853/what-is-the-difference-between-i-and-i