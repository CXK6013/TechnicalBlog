# 我们来聊聊线程安全吧



## 缘起

之前在知乎看到一个问题，京东一面：为什么 HashMap 是线程不安全的？看到这个问题我的第一个反应是，什么是线程安全，我还是饶有兴致的向我自己提问，然后期待一个像是数学定义一样的答案。那么什么是线程?  从操作系统的角度来看，为了实现任务并发，提高CPU的使用率，我们引入了进程，一个执行的程序在等待资源的时候，我们完全可以让CPU干点别的活，于是进程出现了，进程是动态的，程序是静态的，执行中的程序就叫进程，当一个程序开始执行，操作系统需要向他分配内存资源，这么一看进程可以看做是执行逻辑和资源的结合体，像是下面这样:

![](https://a.a2k6.com/gerald/i/2023/10/31/5fje4.png)



但是随着发展，程序开始集成越来越多的功能，像是一个音乐播放器，在最开始只具备打开本地文件播放的能力，慢慢的可以实现在线播放，在线播放，在线播放事实上分成三个动作，下载，解压，播放，由于我们目前只实现了进程级别的并发，那将这三个动作拆分到不同的进程里面，那不同的进程共享资源其实是一个麻烦的问题，那能不能简单点，这三个功能本身就算在这个进程里面，实现进程内部执行单元的切换:

![ ](https://s1.wzznft.com/i/2023/10/31/shcksd.png)

当然可以，那么该如何实现呢，已知是现在有进程，那么一种选择就是将原来的进程改造的轻量级一些,  然后还能共享地址空间和其他资源，以前的进程概念用于刻画执行中的程序，那么改造之后的轻量级进程则用户刻画程序内部的执行流，所以这就是线程嘛，某种程度上我们可以将其当做内核级别的线程实现，但与最初的线程有着一点区别，早期的Linux事实上只支持用户态的线程，也就是说进程内部线程的切换是由进程内部来控制的，这对于早期的开发者来说是一个挑战，说起这个，你想到了什么，有没有想到Java的线程模型，早期Java的线程被称为绿色线程，线程的切换依赖于JVM，采用这一模型的原因在于Java出生于1996年，1997年，JDK 1.1 发布，而在工业界的第一款双核CPU于2001年发布，这款CPU来自于IBM，名叫 Power 4，我们可以认为在Java刚出生的年代还是单核处理器的天下，而在单核处理器下面绿色线程的性能是要更好的，虽然这对开发者不大友好，自己实现一套线程切换调度。所以早期的线程就是用户态的线程，只是为了更加强大的并发，更加友好的体验，更方便的共享资源，但是很快单核心的处理器遇到了瓶颈，处理器晶体管越多、频率越高，越无法稳定运行，同时发热量越大，高频产生的高温需要更极端的散热系统。所以，频率提升不上去了。所以欢迎光临多核时代，所以我们需要更加充分的利用多个核心，由此Linux就推出了线程的轻量级进程实现，这也就是原生线程，原先归虚拟环境调度的多线程被移动到了操作系统身上，对于开发者来说多线程切换更加容易，也能够更加充分的利用多核心，这也是Java改动线程模型的原因，适应多核时代。

当我问我自己什么是线程的时候，我当即给出的答案是一个独立的执行单元，我的回答想来是从Linux线程的实现来说的，这么说似乎也没什么问题，从调度程序的角度来说也只考虑进程，但是从用户角度来说，线程通常是要依附于进程，这么说线程是独立的执行单元也似乎有些问题。那一个目前可以接受的答案是线程是进程内部的一个执行流，进程是正在执行中的程序，有了线程之后，我们就可以将进程看成资源与若干执行流的结合体。我们的目标就是给出线程安全的一个定义，给出一个充分必要条件，像下面这样:

> 线性方程组有解的充分必要条件是其系数矩阵的秩等于其增广矩阵的秩

但也许这是一厢情愿，一切问题并非是数学问题， 我想起数学的公理化，那什么是公理化，粗略的说就是给定一组最基础的公理，在这个基础上推导出这个领域的定理，像是欧几里得几何，严谨一点的说法是:

> **公理化**是数学中一种思想方法, 即对某个 (可能来源于直观或者其它理论的) 研究对象, 找出其中的一些基本对象并列举出想让这些对象满足的一些关系. 这些关系称为**公理**, 对象和关系全体称为**公理系统**. 之后在建立理论时, 不去管这些公理为何成立, 且只使用这些公理而不借助于其它理论来推导.

我想起杨振宁公理化的论述:

> 到20世纪初，有很多人试图将热力学公理化。我认为这不是一个很有用的东西。物理学是关于现实的，而现实是非常复杂的，它不像欧几里德几何那样可以被公理化。如果你真的想要绝对合乎逻辑，你必须在完全确定之前陈述很多很多事情。所以，在我看来，公理化物理学的想法是没有用的。之所以有公理化热力学的讨论，是由于在数学发展到了十九世纪末二十世纪初的时候，出现了将数学公理化的想法，大数学家希尔伯特的厥功至伟。希尔伯特在1900年就23个重要的数学问题发表了著名的演讲，对20世纪的数学产生了巨大的影响。这23个问题中，有一个是将物理学公理化。在我看来，这不是正确的方向。大约在1930年，一位名叫哥德尔的年轻数学家证明，将整个数学公理化的想法并不是完全正确的事情，这导致了数学、数理逻辑和哲学的伟大进步。然后，在没有实现物理公理化的情况下，人们对这个希尔伯特问题失去了兴趣，直到1950年代。20世纪50年代，基本粒子物理学进入了一个探索未来的时期，一些人，尤其是德国的很多人，在某种意义上复兴了这种公理化物理学的想法。当时国际上有许多人去跟风，发展出来一个叫作公理化场论的领域，但是到了1970年代，这个领域也走到了尽头。今天，在这样的方向上进行这种努力并不被认为是推动物理学向前发展的有用尝试。我们在讨论物理学时应当努力成为物理学家而不是逻辑学家。

所以我们本篇的目标，对什么是线程安全做出回答，给出一个数学定义一样的答案，也许根本就做不到，原因在于这个问题也许就没有答案，我们不该用这样的方式对这个问题作出解答，问题的答案可能是另一种形式，但这不意味着探索失去了意义，我们可以给出一个近似的答案，可以让我们在考察线程安全问题时更加得心应手，毕竟造火箭的时候，可能还是让你写一个线程安全的集合的，要回答这个问题，我们至少心里有一个线程安全的定义，定义是充分必要条件的另一种陈述。

那什么是安全，其实提到这个词，我想到的是交通安全，所谓交通安全我想指的就是行动的人正常到达目的地，没有因为违法规则，而出事故。那什么是安全？  在现代汉语词典中，安全的语义为：没有危险；不受威胁；不出事故。 在剑桥英文词典中safe的语义也类似:

> not in danger or likely to be harmed

也就是说这个词的语义是借助其他词的否定来定义的，那线程安全呢，我们首先要考察是在什么情况下会出现安全问题？ 然后通过这些现象给线程安全一个定义。

## 什么情况会出现线程安全问题？

```java
public class SimpleSingleTon {
    private static   SimpleSingleTon singleton = null;
    private SimpleSingleTon(){
    }
    public static  SimpleSingleTon getInstance(){
            if (singleton == null){
                synchronized(SimpleSingleTon.class){
                    try {
                        Thread.currentThread().sleep(100);
                    }catch (Exception e ){
                        e.printStackTrace();
                    }

                singleton = new SimpleSingleTon();
            }
        }
        return singleton;
    }
}
```





想来单线程会出现嘛，应该不会，单线程就是单个执行流，那单个核心呢，多个线程呢，

CPU使用率



## 参考资料

[1] 论文学习之 Linux 调度器  https://juejin.cn/post/7228886005071364157

[2] 《Understanding the LINUX  KERNEL》 third  edition https://www.cs.utexas.edu/~rossbach/cs380p/papers/ulk3.pdf

[3] Light-weight process https://en.wikipedia.org/wiki/Light-weight_process

[4] What is the difference between lightweight process and thread?  https://stackoverflow.com/questions/10484355/what-is-the-difference-between-lightweight-process-and-thread

[5] What are Linux Processes, Threads, Light Weight Processes, and Process State  https://www.thegeekstuff.com/2013/11/linux-process-and-threads/

[6] Why aren't Java threads both lightweight (like green threads) and multi-core capable? (backed by an internal native fixed size native thread pool)  https://stackoverflow.com/questions/67337772/why-arent-java-threads-both-lightweight-like-green-threads-and-multi-core-cap

[7] linux 线程  https://lishiwen4.github.io/linux/linux-thread

[8] 计算机体系结构基础 https://foxsen.github.io/archbase/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%84.html

[9] 为什么十多年前的奔腾4处理器主频就已经3G了，现在处理器还是3G，为什么处理器频率这么多年都没有提高？ 

[10] 物理公理化 https://m.thepaper.cn/newsDetail_forward_23677626

[11] 公理化 https://www.bananaspace.org/wiki/%E5%85%AC%E7%90%86%E5%8C%96