# JMH学习笔记(一)

> 这篇想换成对话体，像柏拉图的《理想国》一样，尝试切换文章的风格。

本篇对话的双方是悟空与龟仙人，这两个也学了Java，龟仙人决定传授给悟空，JMH。于是龟仙人找到悟空。

龟仙人: 悟空，你可曾听过语言之间的性能对比。

悟空： 我听过，一般C++最快，然后是Java之类的。

龟仙人: 所以为什么C++最快呢。

悟空:  这个我学过诶，武天老师，因为计算机最终执行的都是机器码，C++经过编译执行的时候，都是相关平台的机器语言，比如我在Windows下面就是exe，但是C++可移植性不好。

龟仙人: 你说的移植性不好是什么意思，你指的是我写了一个简单的小程序，就是hello world，在Windows上写了一个HelloWorld像下面这样:

```c++
#include <iostream>

using namespace std;

int main()
{
    cout << "Hello world!" << endl;
    return 0;
}
```

这个到mac下面就编译不了？

悟空: 当然不是，武天老师，这个文本在.cpp文件照样可以编译，高级语言的源代码都具备可移植性，但是最终执行的是对应平台的可执行文件，在Windows后缀为.exe。但是Linux并不认识这个文件，所以C++在部署的时候要针对各个平台输出可执行文件。有时候你用了对应平台的库函数，比如我想做网络编程，我就需要调操作系统提供的能力，但是Windows上有一套，Linux上有一套，也就是说C++在使用这些能力的时候，要针对不同的平台做适配。想到这里，武天老师，我想说，那做C++服务端是不是有些头疼，每个平台都要写一套，这我还能下班呢。

龟仙人哈哈大笑道: 1974年，贝尔实验室正式对外发布Unix，贝尔实验室还对外提供了源代码，于是就出现了好些独立开发与Unix基本兼容但是又不完全兼容的OS，20世纪80年代初期，Unix越来越不兼容，因为很多Unix厂商通过加入新的特性来使他们的程序与众不同，是啊，与众不同啊，那这位编写软件带来了巨大的麻烦，每个都要写一套，真是让人头痛啊，为了提高兼容性和应用程序的可移植性，IEEE(电气和电子工程师协会)开始标准化Unix的开发，这也就是Posix，这套标准涵盖了很多方面比如网络编程接口，线程、网络编程。我们熟悉的Linux就实现了POSIX兼容，苹果的操作系统就是基于Unix的。好，悟空，你接着说，C++为什么快，Java为什么慢。

悟空: Java最终输出的是中立平台的jar，jar执行的时候需要JDK环境，因为编译最终输出的是独立于平台的产物，所以有非常良好的可移植性。因为不能编译的不是对应平台的机器码，所以Java就慢一些。

龟仙人: 还有什么要补充的呢？

悟空想了想，接着说道: 

## 参考资料

[1] Linux网络编程基础API https://swordandtea.github.io/2020/11/06/hight_performance_linux_coding/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/

[2] posix是什么都不知道，还好意思说你懂Linux？https://zhuanlan.zhihu.com/p/392588996
