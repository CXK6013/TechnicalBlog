# 用Java的BIO和NIO实现HTTP服务器(一) BIO与 绪论

[TOC]

## 前言

关于网络相关的文章已经写过很多了:

[1]《计算机网络引论》

[2]《计算机网络安全引论》

[3]《NIO 学习笔记(一)初遇》

[4]《Socket简介和I/O多路复用》

[5]《NIO 学习笔记(二)相识篇》

[6]《NIO学习笔记(三) 甚欢篇》

[7]《Netty学习笔记(一)初遇篇》

[8]《HTTP/2.0的二进制是什么?》

[9] 《我们来聊聊HTTPS吧》

[10] TCP 学习笔记(三) 可靠传输

[11] HTTP学习笔记(三) HTTP/2

[12] TCP学习笔记(二) 相识篇

[13] HTTP协议学习笔记(一) 初遇篇

[14]  TCP学习笔记(一) 初遇篇

本系列打算糅合这些文章，使用Java写一个简单的HTTP/HTTPS服务器，我的预设是希望读者诸君已经看过上面的文章了，但是数了数上面大致有十四篇了，希望 读者诸君已阅上面的文章，想来有些奢望。那这里大致的理理这些文章的结构，并给出一个阅读本篇的最小知识点。让我们从网络通信开始说起，如果通信的双方不是面对面，那么交流就要借助于载体，我想起小时候经常看的武侠电影，卧底将情报绑在信鸽的腿上，但是这样传递情报的方式，情报就有被篡改、丢失、截获的风险。篡改、丢失、截获，这也是通信要面临的三个问题。随着时代的发展，越来越快的交互信息变得越来越迫切，计算机帮助我们完成任务之后，我们希望也在计算机上完成信息的交换，那么要完成信息的交换，两台计算机势必要有信道，信道是传输信息的通道，但是有了通道还不够，通信的双方还需要彼此知道地址，有了地址还不够，我们还要避免信息的截获、丢失、篡改。

在通信的时候，通信的双方是明确的，也就是说我知道我要和谁通信，以上就概括了两台计算机通信要面临的问题，面对这么多问题，计算机互联网的先驱们，选择了分层来解决问题，两台计算机之间的信道被划到物理层，信息最终要转变为信号，而物理层就负责传输信号。单纯的0和1没有任何意义，必须规定解读方式，多少个电信号算一组？ 每个信号位有何意义？ 如果我们只有两台计算机，信号送给是明确的，最早的网络是猫+电话线，连一条电话线。理论上双方只要完成拨号，双方就能进行通信。这个过程跟两个人打电话没什么区别。如下图所示, 图片来自https://labpub.com/learn/silver/wi7/modems.html

![img](https://labpub.com/learn/silver/wi7/modem_2.gif)

这种链路我们称之为点对点链路。点对点链路的有点是简单，缺点是每加入一台计算机，就要给电脑新配置一个猫，如果我有多台电脑，这些电脑需要互相连接，就需要每个电脑的猫连接到一起，这带来的成本很高，管理成本也非常重，这种连接方式被称为全网状拓扑(Full Mesh)网络。这种连接方式也不是一无是处，优点是可靠性高，网络中部分链接出现故障不会影响到整个网络。但成本高，维护困难是真的承受不住。

![img](https://pic1.zhimg.com/v2-093d6a428365f6d0df17c4a6df0d9054_r.jpg?source=1940ef5c)

为了降低成本，人们想到了另外一种连接方式，也就是所有的电脑只需要连接一个猫，然后所有猫连接到同一条网线上(叫总线)。我们称这种连接方式为总线网络。这种方式的确降低了组网的成本，但是使用成本却上升了。如果上图中的A想给B发送数据，可以启动自己的猫发送，那么如果此时C和D发数据，那么就会形成干扰，最终谁的数据也发不出来。为了解决这个问题，人们规定，如果想发数据，必须先试用自己的猫听一下网线上有没有其他电脑正在通信。如果有，就自觉等待一段时间，然后再检查。这套机制后来演化了成载波侦听多路访问/碰撞检测(CSMA/CD)机制。教科书上都会将这个CSMA/CD(我已经给忘记了)。

解决了冲突问题，总线网络就能工作吗？当然是不能的! 我们在签名讲的点对点两边各有一台电脑，收房双方非常明确，不需要额外信息。那么在总线网络中，所有电脑共享一条电缆，可以同时接收网络上的全部信号。那大家如何确定数据是如何发给自己的呢？为了解决这个问题，人们发明了数据帧这个概念。帧是发送数据的最小单位，当时有很多链路层协议，以太网只是后面涉及的一种。但是不同的帧结构都是大同小异，核心都包含目标地址、源地址和数据三部分，这也是和寄信一样，信封是携带了发送人的地址、收信人的地址、信内容。

![img](https://picx.zhimg.com/80/v2-c88cbfed6264fc4f871346592e192468_720w.webp?source=1940ef5c)

这里首次出现了地址这个概念。正是因为总线网线中所有设备共享总线，所以需要通过引入地址的概念来区分不同的设备。对于以太网，这个地址就是我们常说的MAC地址。这个时候猫已经变成了我们现在常说的网卡了。以太网规定MAC地址占6个字节，也就是前面说的48位。

所有发出的包都带着目标电脑的MAC地址。网络中所有设备收到数据后悔自觉比较目标地址是不是自己，如果不是就丢弃，是的，你没有听错，全凭大家自觉。这样就解决了上面我们提出的问题。

引入地址的概念，也就产生了新的问题-如何给计算机设置MAC地址呢？ 不同的网络有不同的处理方式。

曾经有一种叫ARCNET的网络协议，它的MAC地址只有1个字节(8位)，需要网络管理员通过网卡上的拨动开关手工设置开关设置。好在当年能连网的设备很少，8位地址可以支持最多256台设备连网，也够用了。

![img](https://picx.zhimg.com/80/v2-7ab58e16a320d5bc04e7842db790cbbc_720w.webp?source=1940ef5c)

以太网规定在网卡出厂的时候就得分配48位MAC地址，全球唯一。

随着总线网络的普及，越来越多的大公司或者是大学开始使用网络连接它们的设备。为了方便传输数据，人们还发明了网桥，我们可以将网桥想象成装有多个网卡的设备，每个网卡连接一个总线网络。网桥唯一的作用就是把一个网卡收到的内容原样转发到另一张网卡所在的网络。

![img](https://picx.zhimg.com/80/v2-ccdeabbffbfbd33f42979d610f2df7cb_720w.webp?source=1940ef5c)



这样网络的规模越来越大，连网的设备越来越多，通信冲突的频率页越来越高。最终的结果就是数据传输的越来越低(因为只要有一个人在发数据，其他所有人都得等待)。但就这样，人们对互联互通的要求还是没被满足。除了公司或者组织内部的网络，人们还想把不同城市的设备和网络都连起来，这就需要用到长途电话线。

前面我们说过网桥是一种无脑转发设备，它的无脑不仅体现在不关心数据内容方面，还体现在尽机子最大能力转发。如果是相同局域网，两边的网速相机，那不会有什么问题。那如果一边是局域网，一边是长途电话线，那么来自局域网的广播数据会把电话线鸡煲，大家谁也别想玩。

既然出现了这样的问题，我么就需要对网桥进行改造，我们希望那个网桥智能一点。让它可以学习不同网络所有设备的MAC地址。当有数据要转发的时候，它可以根据目标地址判断应该转发到哪个网卡，从而减少广播数量。

但是因为以太网的MAC地址是在出厂的时候指定的，那么就没有办法确定某个总线网络中所有的AMC地址，只能通过广播来学习，也只能在网桥设备保存全部MAC地址，而且还要及时更新。除此之外，网桥本身只转发，理论上也不需要MAC地址。所以网络内的计算机知道数据是经过了几个网桥转发，如果出了问题，也不知道在哪个环节出了问题。

最终IETF(Internet Enginering Task Force)给出了解决方案 ，也就是再加一层，也就是在以太网之上引入了网络层(也就是IP层)。  就是引入逻辑地址，这也就是IP地址，而且觉得32位差不多够用了，甚至都没考虑MAC地址都是48位。通过IP地址我们就可以将网络划分成许多个子网，根据逻辑地址，我们就能知道要转发给哪个网卡了，从而减少广播数量。所以，每个设备想要加入一个网络都需要被分配一个IP地址，通信的双方使用IP地址进行通信。IP地址是管理员按需指定的，可以根据前缀聚合。所以原来的网桥，现在变成了路由器，不需要保存网络中所有的MAC地址，只要保存网络前缀就能进行转发。

![img](https://pica.zhimg.com/80/v2-ecf79d7db7b32d588532dd91521f78fc_720w.webp?source=1940ef5c)

那么请问，如何根据逻辑地址得到目标的mac地址呢？ 这也就是ARP协议。每当电脑在通信之前会先在网络上发一个广播(这个广播不会被转发到其他网络)， 问谁的IP地址是某某，这个时候对应的电脑就会回复，是我，我的MAC地址是某某某。发送方就当拿到了接收方的MAC地址，进而完成通信。

如果目标电脑在另一个网络，这个时候发送方就会在自己的网络里广播说拥有网关ip设备的是谁(我们假设它的默认网关IP是192.168.1.1)，网关就会回复自己的MAC。然后，发送方就会通过网关的MAC地址给网关发送一条IP报文，报文的目标IP就是接收方的IP地址，来源IP自然也就是发送方的IP地址。网关是两个子网的桥梁。

那如果不在一个网络呢，我们来举例讲述这个通信过程，假设H1想和H2发送数据，H1在不知道H2在不在一个网络里面，首先在自己所在网络里广播，谁的IP是某某某，没人回复之后，就知道H2和自己不在一个网络了，这个时候他就会通过ARP协议解出来网关的mac地址，然后给网关的mac地址发送了一个报文，报文的目标ip是h2的ip，源ip地址是H1的ip地址，路由器收到这个报文之后，根据目标地址确定目标ip在哪一个子网下面，转发给对应的路由器R2，路由器R1保存了H2所在网络的前缀上，然后由路由器R2转发给H2, 如此就完成了通信过程，

整个过程，H1和R1都不需要知道H2的MAC地址，但所有节点必须知道相临节点的MAC地址（也叫下一跳）。所以说，到现在为止，哪怕是引入了IP层，实际通信还是依赖MAC地址。在IP网络中，如果模板在同一个网络，则通过广播进行通信; 否则，则通过网关转发。因为有广播的存在，所以网速还是会受到影响，这时每个局域网也叫冲突域。因为IP网络引入了路由器，所以跟原来的总线网络相比，冲突域变小了，广播减少了，网速提高了。但是我们还希望网速更快，于是我们发明了交换机，交换机也是一种局域网设备，功能和前面说的网桥类似，但是交换机可以进一步减少广播的数量。

但是，交换机可以进一步减少广播的数量。以上图为例。如果A想给C发送数据，它会先通过ARP广播查询C的MAC地址。这一步是免不了的。但是，这一步也会被交换机监听/学习到，所以交换机会将C连接的网口跟C的MAC地址绑定到一起，等A给C发数据的时候，交换机只会给C发数据。这个时候B和D都收不到数据。不但收不到，B和D还可以在A与C通信期间进行通信，这就进一步提高了网络的利用效率。

网络在发展的同时，计算机也在发展，两台计算机进行通信，本质上是两台计算机上的进程进行通信，那么一台计算机是可以运行多个进程的，那么ip层上报的报文，该交给哪个进程呢，由此就引出了传输层，传输层引入了端口这个概念，来解决这个问题，ip加上端口，就能知道报文交给哪个进程进行处理。但数据一定能送到嘛，这也是我们上面提出的数据丢失问题，丢失了怎么办，再重传，这也就是传输层要考虑的问题。传输层协议交给进程的是字节流，通信的双方需要制定规则才能解析出有意义的报文，由此就引出了应用层协议。

那么作为开发人员，我们该如何使用网络协议，操作系统提供了对应的实现，各个高级语言一般都内置了调用，目前来说只有几种可供应用程序使用的TCP/IP的应用程序接口，最著名的就是美国加利福利亚大学伯克利分校为Berkeley UNIX操作系统定义的API，被称为套接字接口(socket interface)。微软在其操作系统中采用了套接字 API，但是有一点不同，我们称之为Windows Socket。AT&T的Unix System V版本定义的接口，简写为TLI(Transport Layer port)

我们可以认为套接字作为进程和运输层协议之间的接口，像下面这样。



![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ad770ac7b1443bfa71ea662fbd9d0e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

请注意: 在套接字以上的进程是受应用程序控制的，而在套接字以下则属于操作系统的控制。因此，只要程序要使用TCP/IP协议进行通信，它就必须调用操作系统提供的网络通信接口。这里的套接字是一个相对来说有些抽象的概念，那么该怎么理解这里的套接字呢? 为什么说这里的套接字? 因为在其他语境下套接字拥有其他语义，但是也叫套接字。我认为这里的套接字的就是一个规则、协约、机制 : 当程序需要使用网络通信时，必须首先调用操作系统提供的Socket接口，也可以称之为发出Socket系统调用，请求操作系统创建一个"套接字"。这个调用的实际效果就是请求操作系统把网络通信所需要的的一些资源(CPU时间,网络带宽、存储器空间等)分配给该应用进程。操作系统为这些资源的总和创建一个套接字描述符的号码(小的整数)来表示，然后将这个套接字描述符返回给应用进程。此后，应用进程所进行的网络操作(建立连接、收发数据、调整网络通信参数等)都必须使用这个套接字描述符。

到现在为止一切都很好，不好的是，我们的信息是明文，有被窃取篡改的风险，要防止窃取和篡改，我们可以使用SSL/TLS协议, 详细的可以参看:

- 我们来聊聊HTTPS吧

这个系列考虑的使用Java的API写出一个BIO和NIO模式下面的HTTP/HTTPS服务器，有了上面的知识，我们已经对网络有一个基本的了解了，下面就开始用Java构建HTTP/HTTPS服务器。

## BIO模式的服务器

BIO/和NIO处理连接的策略不同，但是共同点都是使用了TCP协议，也就是它们都需要监听端口，只是启动的时候处理处理请求的方式不同，我们抽象出来一个基类，我们就姑且命名为Server, 这个Server是一个抽象类 ，我们通过ServerSocketChannel这个类监听端口，所以Server类里面需要有一个ServerSocketChannel成员变量，在ServerSocketChannel我们可以配置当前的使用哪种网络模型, NIO还是BIO：

```java
// true 代表BIO,false代表NIO
public final SelectableChannel configureBlocking(boolean block)
```

默认模式即是BIO,我们当前构建的就是BIO模式下面的HTTP服务器，我们上面说到我们想要使用应用层的协议需要端口，所以Server这个抽象类里面还需要一个端口初始变量，我们还想要我们的HTTP服务器支持HTTPS协议，但有希望这个是灵活配置的，那么Server也需要一个成员变量来切换HTTP、HTTPS模式，除此之外，TCP是面向连接的，但是服务端处理客户端请求建立的连接也需要时间，ServerSocket会维护一个队列，还没来得及处理的连接就会放到这个队列里面，如果队列已经满了，就会抛出连接被拒绝的异常。 所以我们的成员变量要要有控制队列大小的参数。

到现在为止，我们就可以通过ServerSocketChannel来拿到SocketChannel了，操作系统会将数据通过通道送入到Buffer中，那这里我们可以在设计一个类，将通道的数据处理到ByteBuffer中，那既然要处理到这个ByteBuffer里面，所以我们这个类里需要有一个ByteBuffer的成员变量，这里我们简单的讲一下ByteBuffer，本文的思路是在用到的哪些概念的时候，就会讲哪些，讲的刚好够用。要给SocketChannel读，首先我们得创造ByteBuffer这个对象: 

```java
ByteBuffer byteBuffer = ByteBuffer.allocate(4096);
```

 我们可以将ByteBuffer当做一个装数据的容器，那对于容器我们自然就关心如何存取，那如何存呢，ByteBuffer里面以put开头的就是将数据放入ByteBuffer中的方法，如果我们放入ByteBuffer的数据超过了设定的大小，就会抛出BufferOverFlowException这个异常:

```java
 ByteBuffer byteBuffer = ByteBuffer.allocate(1);
 byteBuffer.put("hello world".getBytes(StandardCharsets.UTF_8));
```

存的问题，我们解决了，下面我们来解决如何取的问题，在读之前，我们需要介绍一下Buffer的几个重要属性，来帮助我们理解我们取数据，为什么要这么取。在ByteBuffer里有以下几个变量:

- mark
- position
- limit
- capacity

capacity是ByteBuffer的大小，





## 总结一下





## 参考资料

- 有了 IP 地址，为什么还要用 MAC 地址？ https://www.zhihu.com/question/21546408
- java socket编程中参数backlog的含义  连接呗
