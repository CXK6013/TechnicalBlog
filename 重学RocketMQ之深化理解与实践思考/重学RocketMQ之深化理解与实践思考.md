# 重学RocketMQ之深化理解与实践思考(一)  结构与消息

[TOC]

## 引言

最近在零拷贝、分布式事务消息，架构的认知上有了新的理解，于是重新打算学习一下RocketMQ，关于RocketMQ的文章已经写了三篇:

-  《消息队列引论》

- 《RocketMQ学习笔记(一) 初遇篇》
- 《RocketMQ学习笔记(二) 相识篇》

关于零拷贝这里讲了三篇《译: 通过零拷贝实现高效数据传输》、《操作系统与通用计算机组成原理简论》、《NIO 学习笔记(一)初遇》，本篇尝试融合这几篇的知识点，做到理论与实践相融合。

## 概述

按照最初的设想是消息队列引论，总体论述消息队列，然后后面跟kafak、RabbitMQ、RocketMQ，到现在为止只学了RocketMQ，在《消息队列引论》里面我们首先讲消息队列的定位，首先消息队列是一个队列，队列是一种组织数据结构的形式，也就是数据结构，这种数据结构具备先入先出的，那RocketMQ既然是队列，也保持了这种顺序性，即RocketMQ消息按照进入队列的顺序写入存储，同一队列键的消息天然存在顺序关系，队列头部为最早写入的消息，队列尾部为最新写入的消息。消息在队列中的位置和消息之间的顺序通过位点(Offset)进行标记管理。

在RocketMQ下面队列是消息存储和传输的实际容器，以此来实现队列的数量的水平拆分和队列内部的流式存储，流式操作的语义为基于队列的存储模型可确保消息从任意位点读取任意数量的消息，以此来实现类似聚合读取、回溯读取等特性，这些是RabbitMQ、ActiveMQ等非队列模型不具备的。

在消息队列下面的语境下面，表达的另一种概念是生产者消费者模型，也就是说在消息队列里面一般都会有生产者和消费者，从名字上就可以推断出来，生产者负责生产消息，消费者负责消费消息，还有一个存储消息的地方，在RocketMQ里面这个存储消息的地方叫Broker，那么问题来了， 这三个是如何联系起来的呢? 答案是NameServer:

![](https://a.a2k6.com/gerald/i/2024/08/14/37vi.png)



在我们的图片中生产者通过NameServer将消息存储到Broaker中，消费者通过NameServer对消息进行消费，在这种语境下消息好像是没有区分的一样，生产者生产消息，消息到达Broker之后被消费者消费，实际中的RocketMQ并不是这样，为了对消息进行区分RocketMQ引入topic(主题)和tag(标签)的概念，主题用于标识同一类业务的逻辑信息，主要作用有:

- 定义数据的分类隔离: 也就是将不同的业务类型数据拆分到不同的主题中管理。
- 定义数据的身份和权限:  RocketMQ的消息本身是匿名无身份的，同一分类的消息使用相同的主题来做身份识别和权限管理。

写到这里想起上海的垃圾分类，何尝不是一种分类隔离呢:

![](https://a.a2k6.com/gerald/i/2024/08/16/4hv60.png)

不同的垃圾桶放不同类型的垃圾，不同的主题放不同类型的消息:

![](https://a.a2k6.com/gerald/i/2024/08/16/p3ow.png)

topic容纳的是一种类型的信息，我们可以将其看做是一个分类标准，但有时候一个大分类还不够，我们需要对信息进一步分类，RocketMQ在主题的基础上为我们提供了tag，我们可以将Topic当做一级分类，Tag当做二级分类。

![](https://a.a2k6.com/gerald/i/2024/08/16/5jqq5.png)

这里说的分类是一种业务上的划分，订单状态流转我们可以将其放入到一个主题(topic)，而到达对应的状态则属于对应的标签(tag)。

## RocketMQ的消息类型

### 从普通消息到事务消息

而对于RocketMQ本身又可以根据传输特性将消费分为:普通消息、顺序消息、事务消息、定时/延时消息。 普通消息的普通是相对于顺序消息、事务消息、延时消息来说的，对于普通消息来说它的生命周期有四个阶段: 初始化、待消费、消费中、消费提交。

​	![](https://a.a2k6.com/gerald/i/2024/08/16/wd7z.png)

- 初始化: 消息被生产者构建并完成初始化，待发送到服务端状态

- 待消费: 消费被发送到服务端，对消费者可见，等待消费者消费的状态

- 消费中: 消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ会对消息进行重试。

  这也就是消费重试，消费重试指的是，消费者在消费某条消息失败后，超过一定时间没有收到回复，也会被认为是失败，RocketMQ服务端会根据重试策略重新消费该消息，超过一定次数后若还未消费成功，直接被发送到死信队列里面。

- 消息删除: RocketMQ按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。

然后普通的消息又可以同步发送或异步发送、单向发送，所谓同步发送也就是在调用发送消息的方法之后会阻塞到broker返回结果之后才会往下执行，异步发送不会阻塞，在接收到broker返回的结果之后会执行回调函数，单向发送不关心结果。像下面这样，需要引入的依赖如下:

```xml
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-spring-boot-starter</artifactId>
    <version>2.2.3</version>
</dependency>
```

```java
@Resource
private RocketMQTemplate rocketMQTemplate;

public  void sendMsg(){
    /**
     * 同步发送 会阻塞到broker返回发送结果之后,才会接着执行
     */
    SendResult sendResult = rocketMQTemplate.syncSend("testTopic", "hello world");
    // 异步发送,不会阻塞这里,在发送成功之后执行回调函数
    rocketMQTemplate.asyncSend("testTopic", "helloworld", new SendCallback() {
        @Override
        public void onSuccess(SendResult sendResult) {

        }

        @Override
        public void onException(Throwable throwable) {

        }
    });
}
// 不等待
rocketMQTemplate.sendOneWay("testTopic","hello world");
```

SendResult是一个枚举，有以下几个结果:

- SEND_OK 发送成功
- FLUSH_DISK_TIMEOUT  刷盘超时
- FLUSH_SLAVE_TIMEOUT 同步到从超时
- SLAVE_NOT_AVAILABLE  从不可用

同步发送的好处是可靠性高，但是因为阻塞等待broker返回的结果，异步的好处是不会阻塞代码，吞吐量高，但是一致性和可靠性低，这里我们来举个例子说明一下假设我们下单之后要触发一些动作，比如发短信，如果订单流程失败，消息发送出去了，这就造成了系统不一致。 再举个例子，两个系统之间通信，A系统的某条数据创建或者修改之后需要通知B系统，如果是异步消息，有可能消息先发送出去，A系统的这里的流程还没走完，这也造成了不一致。

那看来为了追求更强的一致性，我们需要使用同步消息？ 但是面临的一个问题如下，如果是发送成功了还好，发送成功我们可以认为到达了broker的内存，还没刷新到磁盘中去，RocketMQ默认是异步刷盘，异步的意思是不必等待刷新到磁盘再返回结果，此时到达了内存上面。再有如果当前的broker角色是ASYNC_MASTER，这意味着消息同步到slave不会等到返回结果。

但是发送失败了，如果返回的是刷盘超时呢，所谓刷盘超时只是broker没有将消息在指定的时间刷新到磁盘中去，但消息已经进入到broker里面了，只是还在内存里面，只有服务器宕机消息才会丢失，返回刷盘超时只会在设置刷盘方式为同步刷盘，默认刷盘时间为5s才会返回。在这种情况下对于消费者来说已经可见了，这也造成了不一致。如果我们将上面的结果都视为发送成功，下面还有一个问题需要我们考虑，考虑发送消息超时，在DefaultMQProducer里面我们可以看到超时时间默认是3s，如果由于网络抖动报了超时，但其实消息已经丢出去了，只是超过了这个时间，那这样看同步消息也没办法解决我们的问题。

从上面的问题中提出来的方案就是我们需要这样一种消息，这种消息在到达broker的时候处于一种不可见的状态，只有在收到生产端的二次确认之后，才对消费者可见，那我们的解决方案就变成了下面这样:

![](https://a.a2k6.com/gerald/i/2024/08/17/17hzce.jpg)

首先我们的消息在发送出去，消息到达broker之后对消费者不可见，然后间隔一段时间之后消费者启用回查逻辑检验业务是否成功，如果成功就将消息改为可见状态，但其实这里还有一个问题，也就是将会查逻辑放在生产者这里，如果在回查的时候应用重新启动，那这段逻辑就丢失了。再有如果更改消息状态失败，还是假设网络波动这次通信失败了，那这个消息就永远对消费者不可见了。于是我们需要为这个方案再打一个补丁，对于这种类型的消息，服务端定期回查。事实上我们上面讲的也就是RocketMQ事务消息的设计思路。代码如下:











### 顺序消息 

而顺序消息则是一种对消息发送和消费顺序有严格要求的消息，对于一个指定的Topic，消息严格按照先进先出(FIFO)的原则进行消息发布和消费，后发布的消息后消费，

这里引出思考

### 延时消息





## 从刷盘到零拷贝

上面我们讲到了刷盘，也就将数据从内存刷新到磁盘上，回想IO流我脑海中出现了几个关键词: 字节流、字符流、

在我们的图片里面出现了master和slave这两个单词，从字面意义上推断也就是主从，用于实现高可用(high availability)，也就是说主节点会向从节点复制数据，复制方式有两种: 一种同步，一种是异步。

