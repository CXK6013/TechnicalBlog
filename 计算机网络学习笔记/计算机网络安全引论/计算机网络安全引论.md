# 计算机网络安全引论

[TOC]

## 引子

按照我的学习计划中是有打算介绍HTTPS、密码学，学习Java中的加密体系的，Java中的加密体系主要是因为有一次对接第三方的单点登录的时候, 第三方给的解密方案不对，导致解不出来，后来是福致心灵了，看了一篇博客，运气好解开了，但是不明白为什么，于是就打算介绍下Java中加密体系的设计。最近在看计算机网络安全相关的东西，发现HTTPS、密码学在网络安全中也有讨论, 于是就打算把这两个方向的前置知识放在这篇文章里面，和网络安全相关的东西糅合一下。只是大致的介绍，建立起高屋建瓴的理解，后面会分块进行介绍。本篇文章基本介绍的内容网络安全问题概述，两类密码体制，密钥分配，以及互联网使用的安全协议。防火墙概述。本身我是想将HTTPS专门独立出来当作一篇文章的，后来发现在介绍应用层使用的安全协议，HTTPS还是，发现还是绕不开。索性将HTTPS也单独算在这篇里面了。

## 概述

大概是在几年前，我就思考网络安全相关的问题，我问我自己什么样的系统才算是安全的，那如果要回答这个问题是不是要定义一下什么叫做安全？ 当时对自己提问了很多问题，但是都感觉不是我想要的答案，但是有的问题找不到的答案，也许是这个问题本身就没有答案，今年在重学计算机网络的过程中，在翻我大学的计算机网络教材中，大概找到了一下答案：网络安全是不可判定的[1]，这句话引用自《Cryptograph and Data Security》,这本书有点庞大，我本来想看看这句话引用自哪里，有怎么样的上下文呢，后来一看下载下来的PDF有18.5MB，就直接放弃了。我对这句话的理解是没有绝对安全的网络。

## 互联网面对的安全问题

计算机病毒是一个流传非常广的名词，但是这是一个泛称，为了讨论下面的安全协议，我们有必要先对计算机网络的安全性威胁做一个分类，后面讨论的密码体制和安全协议都是为了应对我们这里讨论的安全性威胁而设计出来的。

计算机网络的通信中所面临的威胁一般分为两种:

- 主动攻击

 	主动攻击常见的方式有以下几种:

​	 (1) 篡改  截获报文之后，篡改网络上传送的报文。

​     (2) 恶意程序 恶意程序种类繁多,  被大众熟知的就是计算机病毒，我们可以将其类比到生物病毒上，在到达计算机宿主之后，在获得执行权限之后，不断复制，破坏宿主机的运行。计算机蠕虫通过计算机网络通信将自身从一个网络结点扩散到其他节点的计算机程序。17年5月，永恒之蓝蠕虫病毒利用AES-128和RSA算法恶意加密用户文件来勒索比特币。逻辑炸弹，满足条件才执行的恶意程序。后门入侵，利用系统的漏洞进入系统。再有就是流氓软件，安一个在后台安多个的那种。

   (3) 拒绝服务Dos，攻击者不断的向互联网上某个服务器不断地发送请求报文，使得服务器无法正常提供服务。

- 被动攻击

被动攻击是指攻击者从网络上窃听他人的的通信内容，写到这里我想到了一个古装剧画面，卧底的信鸽被截获，于是正派知道了对手的安排，打了一个埋伏。这里攻击我们称之为截获，在被动攻击中，攻击者只是观察和分析某一个协议数据单元PDU(应用层、传输层、应用层的报文都可能被截获)，即使截获的数据对于攻击者来说是不易理解的，但是也可以通过PDU的协议控制信息部分，了解正在通信的协议实体的地址和身份，研究PDU的长度和传输拼读，从而了解交换的数据的某种性质，这种攻击方式也被称为流量分析。

### 安全计算机网络的四个目标

目前在安全协议的设计方面，主要是针对具体的攻击设计安全的通信协议，但如何保证所设计出来的协议是安全的，一般有两种方法：

- 形式化方法

> 形式化的证明是人们所希望的，但一般意义上的协议安全性也是不可判定的，只能针对某种特定类型的攻击来讨论其安全性。对于复杂的通信协议的安全性，形式化的证明比较困难。所以主要通过人工分析的方法来找漏洞。

- 通过经验来分析协议的安全性

一个安全的计算机网络应设法达到以下几个目标:

1. 保密性

> 保密性就是只有信息的发送方和接收方才能懂得所发送信息的内容，而信息的截获者则看不懂所截获的信息。显然，保密性是网络完全通信最基本的需求，也是对付被动攻击所必须的功能。尽管计算机网络安全并不仅仅依靠保密性，但不能提供保密性的网络肯定是不安全的。那为了保密性所以我们就需要使用各种密码技术。

2. 端点鉴别

> 安全的计算机网络必须能够鉴别信息的发送方和接收方的真实身份。

3. 信息的完整性

> 即使能够确认发送方的身份是真实的，并且所发送的信息都是经过加密的，我们依然不能认为网络是安全的，还必须确认所收到的消息都是完整的，也就是信息的内容没有被人篡改过。保证信息的完整性在应对主动攻击时也是必不可少的。
>
> 但信息的完整性和断点鉴别往往是不可分割的，假定你已经准确的知道了发送方的身份没有错，但收到的报文却已经被篡改过, 那么这样的报文显然是没有用处的。因此我们一般在谈到鉴别的时候，有时是同时包含了端点鉴别和报文的完整性。也就是说既要鉴别发送方的身份，也要鉴别报文的完整性。

## 两类密码体制

### 通信加解密模型

![通信加解密模型](http://tvax3.sinaimg.cn/large/006e5UvNgy1h2o2cz2w5vj310q0gwac5.jpg)

上图是一般的通信加解密模型, 计算机A发送数据的时候通过加密秘钥和算法对数据进行加密发送给计算机B，计算机B通过解密秘钥和解密算法对数据进行解密。密码编码学是密码体制的设计学，而密码分析学是在未知秘钥的情况下推演出明文或秘钥的技术。密码编码学与密码分析学合起来即为密码学。如果一个密码体制不能在一定时间内不能被可以使用到的计算机资源破译，则这一密码体制称为计算上是安全的。

1949年，信息论的创始人香农，论证了一般经典加密的方法得到的密文几乎都是可破的，让密码学陷入了危机中，但是随着时代的发展，理论的进步，这个危机又被解除了(我们完全没有可能在一篇文章中解释这个危机是如何被解除的，会专门开一个专题来介绍)。20世纪70年代后期，美国的数据加密标准DES(Data Encryption  Standard)和公钥密码体制(public key crypto-system,又被称为公开秘钥密码体制)的出现成为近代密码学发展史的两个重要的里程碑。

### 对称密码体制

所谓对称加密体制就是指加密秘秘钥和解密秘钥是使用相同的密码体制，数据加密标准DES属于对称秘钥密码体制。它由IBM公司研制出，DES的保密性取决于对秘钥的保密，而算法是公开的。

DES是一种分组密码。在加密前，先对整个的明文进行分组。每一个为64位长的二进制数据。然后对每一个64位二进制数据进行加密处理，产生一组64位的密文数据。最后将各组密文串接接起来，即得出整个的密文。使用的秘钥占有64位(实际秘钥长度为56位，外加8位用于奇偶校验)

DES的保密性仅仅取决于对秘钥的保密，而算法是公开的。DES的问题在于它的秘钥长度，56位的秘钥意味着一共有2的56次方种可能的秘钥，换一种说法就是，共有7.6×10的16次方种秘钥，假设一台计算机1us可执行一次DES解密，假定我们搜索一半的秘钥空间的一半即可找到密钥，那么找到正确的密钥就要花超过1000年的时间。

从上面的论述来看的话，DES的保密性是非常好的，但是好景不长，现在已经设计出来搜索DES秘钥的专用芯片，加上现代计算机CPU能力的不断进步，56位的秘钥，现代的计算机可以做到不到一天的时间就可以找到这个秘钥，所以56位的DES已经不再认为是安全的了。

但是从另一方面来说，20世纪70年代设计的DES，经过世界上无数优秀学者20多年的密码分析，除了密钥长度以外，没有发现任何大的设计缺陷。

对于DES 56位秘钥的问题，学者们提出了三重DES(Triple DES 或记为3DES)的方案，把一个64位明文用一个秘钥加密，再用另一个秘钥解密，然后再使用第一个秘钥加密，写到这里可能有小伙伴会问，为什么中间还要解密一次? 这里的设计是为了向前兼容，假设三个秘钥都相同，这就相等于DES。那如果三个密钥不相同，第二步解密过程不是会失败了嘛，如果第一个秘钥和第二个秘钥不同，则第二步则进行的也是加密操作。

在DES之后，1997年美国标准与技术委员会(NIST)开始了对高级加密标准AES(Advanced Encryption Standard)的遴选，以取代DES。最初有15个方案申报，最终入选的是两位比利时学者Joan Daemen 和 Vincent Rijmen提交的Rijndeael算法被选中，在2001年正式称为高级加密标准AES。

### 公钥密码体制

公钥密码体制(又被称为公开密钥体制)的概念是由斯坦福大学的研究人员Diffie与Hellman于1976年提出的。公钥密码体制使用不同的加密密钥和解密密钥。

公钥密码体制的产生主要有两个方面的原因，一是由于对称密钥体制的密钥分配问题，二是对数字签名的需求。

在对称密钥密码体制中，加解密的双方使用的是相同的密钥。但怎样才能做到这一点呢？通过网络传输？ 那首先要保证网络安全，在传输的过程不被中间人截获。不通过网络的话，简单而又粗暴的方案是：

- 事先约定
- 信使来传输
- 高度安全的密钥分配中心KDC

在高度自动化的计算机系统中，这两种方案都不是那么被人们所愿意采纳，事先约定，就会给秘钥的管理和更换带来很大的麻烦，用信使传输在于互联网是跨越地域的，这显然是不合适的。如果使用KDC也会使得网络成本增加。

对数字签名的强烈需要也是产生公钥密码 体制的一个原因。在许多应用中，人们需要对纯数字的电子信息进行签名，表明该信息确实是某个特定的人产生的。

在公钥密码体制提出不久，人们就找了三种公钥密码体制: 

- ElGamal体制
- Cramer-Shoup体制
- RSA体制

目前最著名的是由美国三位科学家Rivest，Shamir和Adleman于1976年提出并在1978年正式发表的RSA体制。它是基于一种数论中大数分解问题的体制。

在公钥密码体制中，有两个密钥： 公钥和私钥。其中公钥是可以公开给任何人的，任何人只要获得了公钥，就可以使用公钥对信息进行加密，随后可以通过公开信道将加密后的密文发送给接收者。只有拥有公钥对应私有的接收者才能够正确地解密密文。

## 鉴别

在网络传输中仅仅加密报文是不够的的，我们还需要鉴别，即鉴别所收到的报文的确是报文的发送者所发送的，而不是其他人伪造的或者篡改的，这种我们称之为报文鉴别。另一种鉴别是验证通信的对方的确是自己所要通信的对象，而不是其他的冒充者，这种我们称之为实体鉴别。到目前为止我们现在有两种广泛使用的密码散列函数来实现对报文进行鉴别:

- 散列函数

​    散列是我们开发者日常接触到的名词，散列函数有以下特点，输入长度不一定的情况下，输出参数是固定的，并且比较短。不同的输入可能得出相同的输出。

  在密码学中使用的散列函数被称为密码散列函数，密码散列函数的特点是：要找到两个不同的报文，他们具有同样的密码散列函数输出，在计算上是不可行的。

- MD5和SHA-1

​	MD5算法发布于1991年并获得了非常广泛的应用，MD是Message Digest的缩写,  MD5是报文摘要的第五个版本,MD5的作者曾经提出过一个猜想，即根据给定的MD5报文找出一个与原来报文有相同报文摘要的另一个报文，其难度在计算上是不可能的。但是在2004年，中国学者王小云发表了轰动世界的密码学论文，证明可以用系统的方法找出一对报文，这对报文具备相同的MD5报文值，而这只需要15分钟，不到一个小时。“密码散列函数的逆向变换是不可能的”，这一传统概念已经受到了颠覆性的动摇, 又有许多学者开发了对MD5实际的攻击，于是MD5最终被另一种叫做安全散列算法SHA(Secure Hash Algorithm)的标准所替代。

SHA是由美国标准与技术协会NIST提出的一个散列算法系列。SHA与MD5相似，计算起来比MD5要慢一些，1995年发布的新版本SHA-1在安全性上有很大的改进，但是在SHA-1也被证明其实际安全性并未达到设计要求，并且也被王小云教授的研究团队攻破。于是就有了SHA-2和 SHA-3.

### 报文鉴别

下面我们来大致讲述报文鉴别的过程。我们先给出一个简单的模型，然后指出他的问题，再演进我们的模型。

（1） 用户A首先根据自己的明文X计算出散列H(X)(假定使用的就是MD5)，为了方便叙述我们把得出的散列值H(x)简单记为H

  (2)    用户A把散列H拼接在明文X的后面，然后发送给B

  (3)    用户B收到了这个A的报文之后，因为散列值的长度是固定的，因此B可以将A的报文拆解为明文和散列值，然后B通过散列函数对明文进行计算，计算明文的散列值，如果算出来的散列值等于拆解出来的，那就似乎可以确认这个明文是A发送过来了吗？

假设攻击者C自己做了个明文并且得知了双方的散列函数，那么就可以假装自己是A了，从而达到窃密。为了防止这种现象的出现，我们将鉴别模型改成了下面:

![报文鉴别](http://tvax4.sinaimg.cn/large/006e5UvNgy1h2o85r77loj310g0ivadg.jpg)

 发送方A将报文经过散列函数转换为散列值之后，就用密钥K对散列值进行加密，这样得出来的结果叫报文鉴别码(Message Authentication Code)。请注意的是网卡地址也是MAC，这里要注意区别开来。B收到扩展报文之后，先将报文鉴别码和报文X分离出来，然后用密钥对MAC进行解密得到散列值，然后拿解出来的散列值和用报文计算出来的散列值做比较，如一致就可以相信所收到的报文X确实是A发送的。这样第三方也无法伪造报文，因为没有掌握密钥。现在已经有了好几个不同的MAC标准，使用最广泛的就是HMAC，它可以和MD5或SHA-1一起使用。

但上面的模型还有一些问题，比如发送方和接收方该如何共享密钥，我们仍然可以采取公钥体制，发送方用私钥对散列值进行加密，得到报文鉴别码MAC，然后将报文鉴别码拼接到报文X后面。接收方收到报文后，分离报文鉴别码和报文，用公钥对报文鉴别码解密后对比报文散列后的值。

### 实体鉴别

实体鉴别的目的是验证通信的另一方是自己通信的对象，与报文鉴别的不同在于，实体报文只需鉴定一次即可。我们仍然从一个简单的实体鉴别模型开始说起，发送方为A发送带有自己身份A和口令的报文并且使用双方约定好的对称秘钥K进行加密。B收到报文后用对称密钥K进行解密从而鉴别了B的身份。

我们现在请出小C来指出这个问题，小C同学表示我首先截获了A的报文，这里我就不解密了，因为解密可能要花费很长时间，我截获之后，这份报文就由我来发送给B，这样B就将我当成了A。这就叫做重放攻击，极端一点，C甚至可以截获A的IP地址，然后把A的IP地址冒充为自己的IP地址(这就叫做IP欺骗)，从而使得B跟你更加相信C。

为了应对重放攻击，A和B引入了不重数策略，不重数就是一个不重复使用的大随机数，A首先用明文发送其身份A和一个不重数R给B，接着B响应A的查问，用共享密钥对R进行加密后发回给A，同时也给出了自己的不重数R1, 最后A再响应B，用共享密钥对R1进行加密然后返回给B。这里很重要的一点是A和B的不同会话必须使用不同的不重数，由于小C没有拿到密钥C，那么即使小C发送给A报文，也冒充不了。

在公钥体制下，虽然不用秘密的共享密钥，可以对不重数进行签名鉴定，B用私钥对不重数R进行签名(这里的签名可以理解为加密)，A用B的公钥进行验证，如果能得出自己发送的不重数就可以验证通信的是B了。

但是小C同学说，我还有办法，小C首先冒充是A，发送报文给B，说：“我是A”。

B选择一个不重数R发送给A，但被C截获了。

C用自己的私钥冒充是A的私钥，对R进行加密，并发送给B。

然后B向A发送报文，要求A将解密的公钥发送过来或者能去什么地方获取公钥。然后这个报文也被C截获。

于是C将自己的公钥发送给了B，B用收到了公钥进行验证，验证成功。然后此时通信的对方就变成了C和B再通信。

但是小A和小B说我们用到重要的信息会打电话确认，这样就很容易拆穿你的把戏。

但是小C说我还有升级的策略，A想和B进行通信，向B发送“我是A”的报文和不重数，并给出了自己的身份，这个报文被小C截获后，将C原封不动的转发给B。B选择一个不重数用私钥进行加密，发送给A，此报文也被C截获，C接着将此报文转发给A，然后A用自己的私钥再加密一次发送给B，然后被C截获，C用自己的秘钥加密了B的报文，为了解开双方的密文，此时B要求交换公钥，C给了自己的公钥给B，B将公钥给了C，冒充身份完成。

通过上面的描述我们可以看出，如果在通信过程中将公钥进行传输，是难以避免中间人攻击的，但是公钥也不能哪里都查到，一旦哪里都查到，通信过程还是一样会被中间人攻击，为了避免冒充公钥的现象发生，我们引入了CA(Certification Auth)机构，它一般由政府出资建立，每个实体都会有CA发来的证书，里面有公钥及其拥有者的标识信息(人名和IP地址)，任何用户都可以从可信的地方获得认证中心CA的公钥，此公钥用来验证某个公钥为哪个实体所拥有。

为了使CA的证书具备统一的格式，ITU-T制定了X.509协议标准，用来描述证书的结构。在X.509规定要使用ASN.1.   IETF接受了X.509，仅做了少量改动，并在RFC5280中给出了互联网X.509公钥基础结构PKI(Public Key infrastructure)

## 互联网使用的安全协议

我原本计划介绍一下网络层使用的安全协议，网络层使用的IP Sec协议族还比较复杂，这里我们只大致知道网络层使用的是IPSec协议族吧。我们将重点放在运输层与应用层使用的安全协议上。

### 运输层与应用层使用的安全协议

当万维网可以购物，安全问题就被提上了日程，当顾客想要在淘宝购物的时候，他基本默认享受到以下服务:

- 服务器不是假冒的网站，而不是假冒的网站(这一点需要用户认真鉴别，有的诈骗者会发送一个跟真正域名差不多的链接，点进去之后，网站和正版网站长的一样), 如果是正确的网站，则需要在购物过程中，自己的银行卡号密码不被窃取。
- 服务器和客户端需要确保报文内容不会被更改。
- 服务器和客户端需要保证敏感信息不会被第三者窃听。

以上要求可以通过使用下面两个协议来完成:

- 安全套接字层SSL(Secure Socket Layer)
- 运输层安全TLS(Transport Layer Security)

SSL协议是Netscape(网景公司)所开发, 广泛应用万维网应用(也能被其他应用层协议所使用)，SSL作用在端系统系统层的HTTP和运输层之间，在应用层和传输层建立起一个安全的通道，为通过TCP传输的应用层数据提供安全保障。1995年网景公司将SSL交给IETF，IETF在SSL 3.0的基础上设计了TLS协议，为所有基于TCP的网络应用提供安全数据传输服务。现在我们的网络模型就变成了下面这样:

![网络安全模型](http://tvax1.sinaimg.cn/large/006e5UvNgy1h2ob7s0ur9j30hg0fedh6.jpg)

应用层使用SSL的协议恐怕就是HTTPS了，HTTPS的S是security, 表明现在使用的是提供安全服务的HTTP协议。SSL提供的安全服务可以归纳为以下三种:

- SSL服务器鉴别，允许用户证实服务器的身份。支持SSL的客户端通过验证来自服务器的证书，来鉴别服务器的真实身份并获得服务器的公钥。
- SSK客户鉴别，SSL可选的安全服务，允许服务器证实客户的身份。
- 加密的SSL会话，对用户和服务器间发送的所有报文进行加密，并检测报文是否被篡改。

下面来简要介绍HTTPS的的简要工作过程

- 协商加密算法。浏览器A向服务器发送浏览器的SSL版本号和一些可选的加密算法。服务器从中选定自己所支持的算法(如RSA)，并告知A。
- 服务器鉴别。服务器B向浏览器A发送包含其RSA公钥的数字证书。A使用该证书的认证机构CA公开发布的RSA公钥对该证书进行解密。
- 会话密钥计算。浏览器A随机产生一个秘密数用服务器B的RSA公钥进行加密后发送给B。双方会根据协商的算法产生共享的对称会话密钥。
- 双方用会话密钥加密和解密他们之间传送的数据并验证其完整性。

## 总结一下

在网络中安全的传输数据要做鉴别、加密。鉴别分为报文鉴别和实体鉴别，报文鉴别用来验证报文是否被篡改，实体鉴别则用于验证通信双方的身份，验证身份过后，双方通过密钥进行加密，来防止传输数据被窃听。其实写内容的时候也是在进行取舍，一篇文章也不大可能将所有相关的点都涵盖进来，但是本篇也是一条主线贯穿到底，即在实现网络数据安全传输中遇到的问题，以及对应的的解决方案。主体内容来自于大学教材《计算机网络(第7版)》网络安全一章，用自己的方式将这些组合了一下。

## 参考资料

- 基于身份的密码体制是什么？ https://www.zhihu.com/question/26533817/answer/33165735
- 《计算机网络(第7版)》 谢希仁 编著 电子工业出版社。



